{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/flask_request_push_stack.png","path":"images/flask_request_push_stack.png","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/copycode.css","path":"css/copycode.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/copyright.css","path":"css/copyright.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/dark.css","path":"css/dark.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/search.css","path":"css/search.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/copycode.js","path":"js/copycode.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/copyright.js","path":"js/copyright.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/love.js","path":"js/love.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/Flask-专题/index.md","hash":"adcb1905e5c96f5ad0e079b6aa5708490b91a239","modified":1603003047303},{"_id":"source/about/index.md","hash":"10536a310e51b75f5c86ec760224f09903673894","modified":1603290849693},{"_id":"source/_posts/Flask-Hello_World.md","hash":"259043d84958ed0facba7107ceca7299858108a3","modified":1604412426427},{"_id":"source/_posts/Flask-shell-的便利性.md","hash":"aca6560b4657ce2791918e5486bab046b8bb98ab","modified":1604412426365},{"_id":"source/_posts/Flask-sqlalchemy-使用.md","hash":"e8f31dab3e7b920479314caef9779ebc1a82ac96","modified":1604412426408},{"_id":"source/_posts/Flask-中日志的处理.md","hash":"b39a3f622b6af7709b45e9b3a1e4b10b217a0472","modified":1604412426370},{"_id":"source/_posts/Flask-中请求的处理.md","hash":"66599d180df777942cda641b94f3fe07d2209714","modified":1604412426374},{"_id":"source/_posts/Flask-信号.md","hash":"b683fb93683ad74e7c7bbb12c957cdd0990e7e07","modified":1604412426400},{"_id":"source/_posts/Flask-钩子函数.md","hash":"47b65cef8c7bb763b57cf8a3efaebb0d1769eecc","modified":1604412426435},{"_id":"source/_posts/Mysql-事务级别.md","hash":"5badb380a891366d602d887c3515c0f5e682eed5","modified":1604412426404},{"_id":"source/_posts/django中理解mixins.md","hash":"5ab6a4d6951f7f5245c62496e5c694e66b10a40d","modified":1604412426349},{"_id":"source/_posts/eventlet与flask-sqlalchemy的结合.md","hash":"ee4a04f78bce44dcf6e7bbc3e0277916c7cc9c14","modified":1604412426353},{"_id":"source/_posts/flask-sqlalchemy-复杂查询.md","hash":"0cef2cb73c154fbd3cce0f816792e292c588fc73","modified":1604575436623},{"_id":"source/_posts/flask-路由和蓝图.md","hash":"4fd05ece0e03f9c93eada8d9b07c379977e4f4ff","modified":1604412426341},{"_id":"source/_posts/flask上下文应用.md","hash":"7eb461f35d3623fc01bd078d322b4a082c5b95e5","modified":1604412426415},{"_id":"source/_posts/linux-TCP参数说明.md","hash":"45df555017b6db034d770de1f24bb2b368c1bc63","modified":1604412426381},{"_id":"source/_posts/flask模板使用.md","hash":"168988f8fbefd7e641a56b3a2150e33a7ab701d6","modified":1604412426431},{"_id":"source/_posts/python-gc.md","hash":"5cff42d9efc29f452c036f098bf8d2b322375d6a","modified":1604412426361},{"_id":"source/_posts/mysql数据库主从.md","hash":"6d17ad8977663a585acf1b21397152de7b143ef5","modified":1604412426393},{"_id":"source/_posts/python-中的-dataclasses.md","hash":"9a1271ed4014657f442ac049c3a945b5e6f9ae84","modified":1604412426377},{"_id":"source/_posts/python-内存泄漏问题.md","hash":"1e3b73a843f89cde4d3adf2e17bd97455c11c989","modified":1604460231919},{"_id":"source/_posts/redis-基本数据结构-string.md","hash":"6f90eb3b03b4646c64516f2c6aa639606e41f951","modified":1604460205513},{"_id":"source/_posts/python包打包分发.md","hash":"ad009ccb619a92d79790d3678fb693b2a23143f3","modified":1604412426389},{"_id":"source/_posts/rest-fm-data-validator.md","hash":"9567f9469c04f801858d10e07064e1a4a3747230","modified":1604412426424},{"_id":"source/_posts/分布式之负载均衡.md","hash":"ec73180509b46722763a16f3931f3db857747bca","modified":1604412426396},{"_id":"source/_posts/微服务理解.md","hash":"0143e3233bb60334aac466afb9fb41b853900fce","modified":1604412426345},{"_id":"source/_posts/支付掉单现象.md","hash":"c98ad08d97e03e26cee086b13e7b52875f80d445","modified":1604412426420},{"_id":"source/alg专题/index.md","hash":"145470ef55a6eec010a868df3bc6cfea3eb753b8","modified":1602997146249},{"_id":"source/categories/index.md","hash":"ba09c8e17f910d3c2d11c912750fa95074f5e682","modified":1603003683386},{"_id":"source/images/flask_request_push_stack.png","hash":"22998c6105e08377b7b3ffa29b04f66b45afc558","modified":1604397026705},{"_id":"source/php/index.md","hash":"d14b61da139d08577ed78a5eeb096cae01b9d312","modified":1604568501962},{"_id":"source/tags/index.md","hash":"e8c7decbbe7f06e4747cb0e8be15c00568ed1feb","modified":1603003740569},{"_id":"source/thinkphp/index.md","hash":"85f326e1a0be4805a53cd36d9ca8ec7a3268a37f","modified":1604568494838},{"_id":"source/_posts/flask上下文应用/flask_request_push_stack.png","hash":"22998c6105e08377b7b3ffa29b04f66b45afc558","modified":1604397026705},{"_id":"themes/maupassant/.gitignore","hash":"d7d27e5a9bcffe7f90dc2f4f0752e19020e40f40","modified":1602773231797},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1602773231797},{"_id":"themes/maupassant/README.md","hash":"f16e67890be40aece9c1e972abaf0944883a0ece","modified":1602773231798},{"_id":"themes/maupassant/LICENSE","hash":"0663fd3a7ea9fc4f4c634b4d73e2da426b536f86","modified":1602773231798},{"_id":"themes/maupassant/_config.yml","hash":"eea2c38828067631391228057eb901ab7b5db8ba","modified":1604568918723},{"_id":"themes/maupassant/package.json","hash":"41ad91ee4af35617c0f409d42e46485d994af3c0","modified":1603290257681},{"_id":"themes/maupassant/layout/archive.pug","hash":"3770284e425fb0c14d60ae6ac454f58ba07ce76b","modified":1602773231811},{"_id":"themes/maupassant/layout/base.pug","hash":"7451a590db6943edc099dc0e13b317c38686e8fc","modified":1602773231812},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"b0a0ec63ee0225eaa0996d72164202bc9a28a225","modified":1602773231812},{"_id":"themes/maupassant/layout/index.pug","hash":"d1d56fa62f1293cd0cbefe96dbbde2d35b557a0a","modified":1602773231812},{"_id":"themes/maupassant/layout/page.pug","hash":"647bfba2208cbef052e1bf307d30a6775671215d","modified":1602773231813},{"_id":"themes/maupassant/layout/post.pug","hash":"4140dc1dc9c777f4fc1d361f313f5d898d146e7a","modified":1602773231813},{"_id":"themes/maupassant/layout/single-column.pug","hash":"8b4b731cdf86379d526821a1fa950bf15ed61f15","modified":1602773231813},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"9ad3083c2f70fdb460ecbe277be97320a2621196","modified":1602773231814},{"_id":"themes/maupassant/layout/timeline.pug","hash":"04f7efdc45acda1faff409d0f80fa5a0dd2309d0","modified":1602773231814},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1602773231799},{"_id":"themes/maupassant/languages/en.yml","hash":"93674c5df281d7f5647fe500e10924008d8017c6","modified":1602773231800},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1602773231800},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1602773231800},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1602773231801},{"_id":"themes/maupassant/languages/ru.yml","hash":"36edc014c6aaef367d58929089bf7915375e71a6","modified":1602773231801},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"a6fa4ea6c3a59ae6ac13230d6154d1fdd6c149f3","modified":1602773231802},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"795f420382a150d570a06ffc278c4e7819260691","modified":1602773231802},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"a5a2081a060637da1f2ca5ce395607feb496413c","modified":1602773231803},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"92aa15e813bfb411803cc54218feb5410469a9c2","modified":1602773231804},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"2701ce8ecff183d3ecdef3af6528cb1d4e6404e1","modified":1602773231803},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"232ce3da2b0f9366b95aca431be8082eebb1d6c4","modified":1602773231804},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1602773231804},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1602773231805},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1602773231805},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1602773231805},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1602773231806},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"a255fca3557a0dac0ad49c7d4456133420c22bd8","modified":1602773231806},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1602773231806},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"f848b6ac3f44cfd4110a2d1c742c73eacd6285ee","modified":1602773231807},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7707b4c718a935882ee986d0bb0078e50cdbea64","modified":1602773231807},{"_id":"themes/maupassant/layout/_widget/copyright.pug","hash":"44935b31e7b3b6232a9a587775cfe9e90efc6a89","modified":1602773231808},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"7bc7c17cfd498c3e0c3371cef78f08f1dc25db36","modified":1602773231808},{"_id":"themes/maupassant/layout/_widget/donate.pug","hash":"666a89edbc1d7186afba68e0b3bee7e957d7a26e","modified":1602773231808},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"68bae3eb2f80e6127e03faa7ee1b78fb2e70aafc","modified":1602773231809},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1602773231809},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6aa743486f282545f553a4fad6aae037afe26108","modified":1602773231810},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"37f236365b153fc40324391e5a602d6d50014e18","modified":1602773231811},{"_id":"themes/maupassant/public/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1603290264071},{"_id":"themes/maupassant/public/css/dark.css","hash":"0faf42a84e243032b736c5f06ddbb95ac69e779c","modified":1603290264074},{"_id":"themes/maupassant/public/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1603290264074},{"_id":"themes/maupassant/public/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1603290264074},{"_id":"themes/maupassant/public/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1603290264074},{"_id":"themes/maupassant/public/css/style.css","hash":"bac940ea57aadde4bb4694a59ba992d7ca0c4aca","modified":1603290264079},{"_id":"themes/maupassant/public/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1603290264075},{"_id":"themes/maupassant/public/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1603290264077},{"_id":"themes/maupassant/public/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1603290264077},{"_id":"themes/maupassant/public/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1603290264079},{"_id":"themes/maupassant/public/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1603290264077},{"_id":"themes/maupassant/public/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1603290264079},{"_id":"themes/maupassant/public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1603290264074},{"_id":"themes/maupassant/public/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1603290264071},{"_id":"themes/maupassant/public/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1603290264074},{"_id":"themes/maupassant/public/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1603290264074},{"_id":"themes/maupassant/public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1603290264074},{"_id":"themes/maupassant/public/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1603290264074},{"_id":"themes/maupassant/public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1603290264074},{"_id":"themes/maupassant/public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1603290264074},{"_id":"themes/maupassant/public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1603290264074},{"_id":"themes/maupassant/public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1603290264074},{"_id":"themes/maupassant/source/css/copycode.css","hash":"23fefb18f1d4dc7bde33e29d6ae737570277d943","modified":1602773231815},{"_id":"themes/maupassant/source/css/copyright.css","hash":"ad420043e1d0518bfbf3b2a2d87fb5b104587c6f","modified":1602773231816},{"_id":"themes/maupassant/source/css/dark.css","hash":"87f0d84e736c55b2889d6e95025add032ceb0e06","modified":1602773231816},{"_id":"themes/maupassant/source/css/donate.css","hash":"d9ef1520e136198c0ae13acef7da22a275fb4dbf","modified":1602773231816},{"_id":"themes/maupassant/source/css/search.css","hash":"a1720a63170ff4ae9048f634e8e1900e7a3cc45a","modified":1602773231817},{"_id":"themes/maupassant/source/css/style.scss","hash":"0250383e45d3a5ce307cb3a689412c3a9f83b732","modified":1602773231818},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1602773231818},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1602773231819},{"_id":"themes/maupassant/source/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1602773231819},{"_id":"themes/maupassant/source/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1602773231820},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1602773231820},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1602773231820},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1602773231821},{"_id":"themes/maupassant/source/js/copycode.js","hash":"6df3139581744e7bcd47243e4587f5397c2a24c3","modified":1602773231821},{"_id":"themes/maupassant/source/js/copyright.js","hash":"0e9a845ae05d2f00721ff6ee910c8c3cace26043","modified":1602773231822},{"_id":"themes/maupassant/source/js/donate.js","hash":"82f06bd69782c1138c98b4276771a41e3a54c061","modified":1602773231822},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"8a993c1c4ad40789d2960b682cb2130382a0f26a","modified":1602773231823},{"_id":"themes/maupassant/source/js/love.js","hash":"60df5dc3d09c8f33d1d02f54cbc73bf8d62f52fb","modified":1602773231823},{"_id":"themes/maupassant/source/js/search.js","hash":"dbda07a03e6edc73f1dc28a068c24a6037b97b56","modified":1602773231823},{"_id":"themes/maupassant/source/js/share.js","hash":"514e726c1efae9f6566600fa0e945b4b9e620f2e","modified":1602773231824},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1602773231824},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1602773231824},{"_id":"themes/maupassant/db.json","hash":"e29744927243b5b732484259ecf4b210eb5e679f","modified":1603290264087},{"_id":"public/Flask-专题/index.html","hash":"d06b9827f26ed27a951d5c5fc9baee79c6763423","modified":1604575446957},{"_id":"public/about/index.html","hash":"bbd72837a2c3bf3d4ea149e1792fb73b7cc9c7af","modified":1604575446957},{"_id":"public/alg专题/index.html","hash":"27d190c1931568961cece45e2107b666b63cd08f","modified":1604575446957},{"_id":"public/categories/index.html","hash":"e801ff5c564b9a73ecc38f264a1678b494ab1b8f","modified":1604575446957},{"_id":"public/php/index.html","hash":"263cbaf2f34f4cbea6d185b347a98cb8be9fa4a4","modified":1604575446957},{"_id":"public/tags/index.html","hash":"6b00d6ee03bbf989492834987a5817f01e5fe242","modified":1604575446957},{"_id":"public/thinkphp/index.html","hash":"485fc92a69fbe9b78e13792a68c6b814cc82cea4","modified":1604575446957},{"_id":"public/2019/10/22/微服务理解/index.html","hash":"12acff053afa4de9ab938c08144b1bb5dc0d03a8","modified":1604575446957},{"_id":"public/2018/11/03/eventlet与flask-sqlalchemy的结合/index.html","hash":"8f8e905594420e02898ea8c3af214749b2cfe242","modified":1604575446957},{"_id":"public/2018/10/21/python-gc/index.html","hash":"9c7031f48f3e2bda7de711ed3039dcdf12c95482","modified":1604575446957},{"_id":"public/2018/10/20/分布式之负载均衡/index.html","hash":"650431e32a3c63a31b16fcb6c11e25393e211947","modified":1604575446957},{"_id":"public/2018/10/18/python-内存泄漏问题/index.html","hash":"96efd55fe19dc7596cfc74283426af18c3c3f48d","modified":1604575446957},{"_id":"public/2018/09/03/python包打包分发/index.html","hash":"1786214bc00e4459fcf9c3f0cff05069cdb81845","modified":1604575446957},{"_id":"public/2018/08/20/linux-TCP参数说明/index.html","hash":"a2fe7ddd25345269a29c0c1e49c3698dca599955","modified":1604575446957},{"_id":"public/2017/10/28/支付掉单现象/index.html","hash":"f696ed4d00fce5eb850e211dd0dda5474db40d44","modified":1604575446957},{"_id":"public/2017/10/22/django中理解mixins/index.html","hash":"17670d75d7f04b138bc78c52788a10f30b9ad919","modified":1604575446957},{"_id":"public/2017/10/21/mysql数据库主从/index.html","hash":"38d334b653397c038380e0be855a218aa9d9aa08","modified":1604575446957},{"_id":"public/2017/10/21/redis-基本数据结构-string/index.html","hash":"7258107cdeefc4cd28d13221bd32a59071e6026d","modified":1604575446957},{"_id":"public/2017/10/20/Mysql-事务级别/index.html","hash":"b3b84a85406f21d6c01713a4391468197a71e0af","modified":1604575446957},{"_id":"public/2017/10/13/Flask-钩子函数/index.html","hash":"b851a657233786b7e2e3cc9e71ec0babc9505420","modified":1604575446957},{"_id":"public/2017/10/12/Flask-信号/index.html","hash":"41748996286f5fc7d2d25ca4359ebb4327e3a637","modified":1604575446957},{"_id":"public/2017/10/11/Flask-中日志的处理/index.html","hash":"6731e8a29549b7e02fec913aaf4ab0f11432105c","modified":1604575446957},{"_id":"public/2017/10/11/flask上下文应用/index.html","hash":"c8bd8d8b17ca7b71eb42da05ab4ec137600cb5f5","modified":1604575446957},{"_id":"public/2017/10/11/flask-sqlalchemy-复杂查询/index.html","hash":"7519136bb27a4102fb69f0d590fc1bef961239ee","modified":1604575446957},{"_id":"public/2017/10/10/Flask-Hello_World/index.html","hash":"71dd89f1c05377a9eccd8a6645a3df16bba17a43","modified":1604575446957},{"_id":"public/2017/10/10/Flask-中请求的处理/index.html","hash":"dfa9c4acab110c41aa79c5bafb9fe4602aa73cd0","modified":1604575446957},{"_id":"public/2017/10/10/flask模板使用/index.html","hash":"ad26c6d0e93ddfaf261765421531fe1348e78af4","modified":1604575446957},{"_id":"public/2017/10/10/flask-路由和蓝图/index.html","hash":"65171ce4d8c6a865e115b86b24c412b3c9cdbfe8","modified":1604575446957},{"_id":"public/2017/10/10/Flask-sqlalchemy-使用/index.html","hash":"c55b626b7167f98529d1914d384439aa5512198d","modified":1604575446957},{"_id":"public/2017/10/10/Flask-shell-的便利性/index.html","hash":"4ed49556e0f30218d1f61479b4dbeb4019e53e82","modified":1604575446957},{"_id":"public/2017/06/17/python-中的-dataclasses/index.html","hash":"35f4db36f81be8a68624ed7d533bca9b39505ade","modified":1604575446957},{"_id":"public/2017/06/10/rest-fm-data-validator/index.html","hash":"5588f739fa7d770858c3a13a3fec438663960e00","modified":1604575446957},{"_id":"public/archives/index.html","hash":"2ac3667d0d959ebb3851548e15cb3742b71c59e5","modified":1604575446957},{"_id":"public/archives/page/2/index.html","hash":"264905d926b07824d11b703b0f09611b7441ca7f","modified":1604575446957},{"_id":"public/archives/page/3/index.html","hash":"0d87c1ae78f792bfa511f3661726dfd2cf4f8b77","modified":1604575446957},{"_id":"public/archives/2017/index.html","hash":"c7dbc5ac38cb9005ffb174b9e47c369a0f554c6e","modified":1604575446957},{"_id":"public/archives/2017/page/2/index.html","hash":"4eac35ef64d460b458a1deb39a71a98134cc4ff5","modified":1604575446957},{"_id":"public/archives/2017/06/index.html","hash":"69af8fd86eded10f5d22457767222226cf673bde","modified":1604575446957},{"_id":"public/archives/2017/10/index.html","hash":"4f9c8b8273d6aea59a17a58e3e398ca2b41efdec","modified":1604575446957},{"_id":"public/archives/2017/10/page/2/index.html","hash":"7731ebe82e0116ed9fcb5e96a6463344e890b757","modified":1604575446957},{"_id":"public/archives/2018/index.html","hash":"cf985dbbe8c28f3b5d5f511d803582de6f0968e3","modified":1604575446957},{"_id":"public/archives/2018/08/index.html","hash":"91313504a882d0c9970f4ccf26a3500f7e2be256","modified":1604575446957},{"_id":"public/archives/2018/09/index.html","hash":"6531017a9fa9c90b97f118f268c1de10e77084db","modified":1604575446957},{"_id":"public/archives/2018/10/index.html","hash":"430102d03a69e35a4ddcfc7ddc7a7d9c1457f442","modified":1604575446957},{"_id":"public/archives/2018/11/index.html","hash":"3dc5e2254912b747e74661b501a4c27f1fdc2ca1","modified":1604575446957},{"_id":"public/archives/2019/index.html","hash":"a761ffb3758267c2d263ffa2caa827ca909a689d","modified":1604575446957},{"_id":"public/archives/2019/10/index.html","hash":"a761ffb3758267c2d263ffa2caa827ca909a689d","modified":1604575446957},{"_id":"public/tags/Flask/index.html","hash":"8ccfc0107716d41275b574b833160b3d63ab2981","modified":1604575446957},{"_id":"public/tags/Flask-Sqlalchemy-db/index.html","hash":"5cc2960ae665e24581ff3ea2933747ef574cacdf","modified":1604575446957},{"_id":"public/tags/Flask-logging/index.html","hash":"e1aa141c872ac8ccf279011c34cddc1d7a285675","modified":1604575446957},{"_id":"public/tags/Flask-Signal/index.html","hash":"14dda4fc72bbab00976c08bdd52c2ec33b7e0325","modified":1604575446957},{"_id":"public/tags/Flask-钩子函数/index.html","hash":"0cdf42887297dbb4e19aac898e9a9abc2c89de7b","modified":1604575446957},{"_id":"public/tags/Mysql/index.html","hash":"cf348e2c208c97c3608511993d67c7e2c50f2b70","modified":1604575446957},{"_id":"public/tags/Django-设计模式/index.html","hash":"7d435f219e6e1505957b8d33320d0b62f9107ea4","modified":1604575446957},{"_id":"public/tags/Eventlet-Flask-Sqlalchemy/index.html","hash":"925324ad80c3d4e0b817a969e5a8cecefed35d7d","modified":1604575446957},{"_id":"public/tags/Flask-Sqlalchemy/index.html","hash":"71daca003a4d847816704c4ff21df76532da2d99","modified":1604575446957},{"_id":"public/tags/Flask-route-Blueprint/index.html","hash":"ac094e3b1a1ee02bafecff8e6f40e172deba46cf","modified":1604575446957},{"_id":"public/tags/Flask-template/index.html","hash":"b2e2548a97c18a9e3def13865ace0e54491e2fda","modified":1604575446957},{"_id":"public/tags/TCP-Linux/index.html","hash":"6f83862f70a8bba7d1b95ba8cb94110c84d40cb3","modified":1604575446957},{"_id":"public/tags/python-gc-内存管理/index.html","hash":"5253482b367c4cb15de463ea4bf893e20d46d9c6","modified":1604575446957},{"_id":"public/tags/Mysql-主从/index.html","hash":"95c4738bc5b390957ac97d3aa71516a9ea981657","modified":1604575446957},{"_id":"public/tags/python/index.html","hash":"60fdca0b5b8a050fc06fd56f8504900e6422df7a","modified":1604575446957},{"_id":"public/tags/Python-Memory/index.html","hash":"baa1210a10591e833a078cc848559ccd577f38b5","modified":1604575446957},{"_id":"public/tags/Redis/index.html","hash":"f07a3bc103a4fdec139ee2188d82061aa5caaa22","modified":1604575446957},{"_id":"public/tags/build/index.html","hash":"5a0ba0092724e5e9881b202a99d7c4be9a0f87d5","modified":1604575446957},{"_id":"public/tags/rest-validator/index.html","hash":"466d4804ec3662a95449afba108677eb9a9bc054","modified":1604575446957},{"_id":"public/tags/分布式/index.html","hash":"41295389bba67799014dacf8dc99becc2eb0aa8f","modified":1604575446957},{"_id":"public/tags/微服务/index.html","hash":"a39ce2ed4e7620bc281b5d0394946c6e11e2cb04","modified":1604575446957},{"_id":"public/tags/Web/index.html","hash":"b66003fd9ddc2edd3114cdbfa8667e2e720e75ff","modified":1604575446957},{"_id":"public/page/2/index.html","hash":"a23a74dd83e5a0deac519bad0813c7a165f40995","modified":1604575446957},{"_id":"public/index.html","hash":"f06885073fee09b5425b69ef7b4f270620b620c4","modified":1604575446957},{"_id":"public/page/3/index.html","hash":"dfd36ee8d777acb1b97f2934577ad247c6981ecd","modified":1604575446957},{"_id":"public/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1604575446957},{"_id":"public/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1604575446957},{"_id":"public/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1604575446957},{"_id":"public/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1604575446957},{"_id":"public/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1604575446957},{"_id":"public/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1604575446957},{"_id":"public/images/flask_request_push_stack.png","hash":"22998c6105e08377b7b3ffa29b04f66b45afc558","modified":1604575446957},{"_id":"public/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1604575446957},{"_id":"public/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1604575446957},{"_id":"public/css/dark.css","hash":"0faf42a84e243032b736c5f06ddbb95ac69e779c","modified":1604575446957},{"_id":"public/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1604575446957},{"_id":"public/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1604575446957},{"_id":"public/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1604575446957},{"_id":"public/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1604575446957},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1604575446957},{"_id":"public/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1604575446957},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1604575446957},{"_id":"public/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1604575446957},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1604575446957},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1604575446957},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1604575446957},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1604575446957},{"_id":"public/css/style.css","hash":"bac940ea57aadde4bb4694a59ba992d7ca0c4aca","modified":1604575446957}],"Category":[],"Data":[],"Page":[{"title":"Flask 专题","date":"2017-09-30T16:00:18.000Z","tag":"Flask, web","_content":"","source":"Flask-专题/index.md","raw":"---\ntitle: Flask 专题\ndate: 2017-10-01 00:00:18\ntag: Flask, web\n---\n","updated":"2020-10-18T06:37:27.303Z","path":"Flask-专题/index.html","comments":1,"layout":"page","_id":"ckh4qsjd40000o8t2581n71sp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2020-10-21T14:34:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-10-21 22:34:09\n---\n","updated":"2020-10-21T14:34:09.693Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckh4qsjda0002o8t2dldc79ip","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"alg专题","date":"2020-10-18T04:59:06.000Z","_content":"","source":"alg专题/index.md","raw":"---\ntitle: alg专题\ndate: 2020-10-18 12:59:06\n---\n","updated":"2020-10-18T04:59:06.249Z","path":"alg专题/index.html","comments":1,"layout":"page","_id":"ckh4qsjdh0005o8t2apxx52zs","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-05-01T06:47:30.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-05-01 14:47:30\ntype: \"categories\"\n---\n","updated":"2020-10-18T06:48:03.386Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckh4qsjdn0007o8t237y2gxsc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"php","date":"2020-11-05T09:28:21.000Z","author":null,"_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***","source":"php/index.md","raw":"---\ntitle: php\ndate: 2020-11-05 17:28:21\nauthor:\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***","updated":"2020-11-05T09:28:21.962Z","path":"php/index.html","comments":1,"layout":"page","_id":"ckh4qsjdq0009o8t27s9mczko","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4>"},{"title":"tags","date":"2017-05-01T06:48:35.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-05-01 14:48:35\ntype: \"tags\"\n---\n","updated":"2020-10-18T06:49:00.569Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckh4qsjdt000do8t2glfaa829","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"thinkphp","date":"2020-11-05T09:28:14.000Z","author":null,"_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***","source":"thinkphp/index.md","raw":"---\ntitle: thinkphp\ndate: 2020-11-05 17:28:14\nauthor:\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***","updated":"2020-11-05T09:28:14.838Z","path":"thinkphp/index.html","comments":1,"layout":"page","_id":"ckh4qsjdv000go8t2f3gbftne","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4>"}],"Post":[{"title":"Flask 的Hello World","date":"2017-10-10T14:49:26.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n* Flask 是一个python世界的微框架, 由于python语言的web服务器一般都是和web框架分离的.\n  现在就来看看它有多么微\n\n* pip install flask  \n* 创建一个python 脚本\n```python\nfrom flask import Flask, jsonify\n\n# 实例化 Flask app 对象 \napp = Flask(__name__)\n\n# 通过app的route 装饰器将函数变成视图函数, 主要的参数\n# url -> /\n@app.route(\"/\", methods=['GET'])    # UrlPath, HttpMethod\ndef index():\n    # 我们知道python函数可以返回多个值, 在调用方会被组包成元组.\n    # 这里的返回值格式一般为: str_data, status_code, headers(dict)\n    return \"Hello FLask\", 200\n\n# url -> /json/ | /json(访问这个url时, 会被转发)\n@app.route(\"/json/\", methods=['GET'])\ndef json():\n    data = {}\n    resp = jsonify(data)    # jsonify 返回一个 Flask Reponse 实例\n    resp.status_code = 200  # 设置状态码\n    return  resp\n\n```\n* 上面的代码就实现了一个简单的api接口, 由于Flask诞生的比较晚, 所以api 也比较现代化.\n  它希望大部分情况下, 都当作flask 视图函数都当作api来使用.\n\n* Flask 依赖项:\n    1. 提供web开发所需的 Werkzeug wsgi工具箱(提供flask 处理web开发常用的工具)\n    2. jinjia2 模板引擎用来渲染模板\n* web服务器:\n    Gunicorn 部署\n    \n比起的其它的web框架动则几个十几个的依赖简直不要太爽, 自己学习起来也比较舒服.\n","source":"_posts/Flask-Hello_World.md","raw":"---\ntitle: Flask 的Hello World\ndate: 2017-10-10 22:49:26\ntags: Flask\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n* Flask 是一个python世界的微框架, 由于python语言的web服务器一般都是和web框架分离的.\n  现在就来看看它有多么微\n\n* pip install flask  \n* 创建一个python 脚本\n```python\nfrom flask import Flask, jsonify\n\n# 实例化 Flask app 对象 \napp = Flask(__name__)\n\n# 通过app的route 装饰器将函数变成视图函数, 主要的参数\n# url -> /\n@app.route(\"/\", methods=['GET'])    # UrlPath, HttpMethod\ndef index():\n    # 我们知道python函数可以返回多个值, 在调用方会被组包成元组.\n    # 这里的返回值格式一般为: str_data, status_code, headers(dict)\n    return \"Hello FLask\", 200\n\n# url -> /json/ | /json(访问这个url时, 会被转发)\n@app.route(\"/json/\", methods=['GET'])\ndef json():\n    data = {}\n    resp = jsonify(data)    # jsonify 返回一个 Flask Reponse 实例\n    resp.status_code = 200  # 设置状态码\n    return  resp\n\n```\n* 上面的代码就实现了一个简单的api接口, 由于Flask诞生的比较晚, 所以api 也比较现代化.\n  它希望大部分情况下, 都当作flask 视图函数都当作api来使用.\n\n* Flask 依赖项:\n    1. 提供web开发所需的 Werkzeug wsgi工具箱(提供flask 处理web开发常用的工具)\n    2. jinjia2 模板引擎用来渲染模板\n* web服务器:\n    Gunicorn 部署\n    \n比起的其它的web框架动则几个十几个的依赖简直不要太爽, 自己学习起来也比较舒服.\n","slug":"Flask-Hello_World","published":1,"updated":"2020-11-03T14:07:06.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjd70001o8t2fvlg774n","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><ul>\n<li><p>Flask 是一个python世界的微框架, 由于python语言的web服务器一般都是和web框架分离的.<br>现在就来看看它有多么微</p>\n</li>\n<li><p>pip install flask  </p>\n</li>\n<li><p>创建一个python 脚本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实例化 Flask app 对象 </span></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过app的route 装饰器将函数变成视图函数, 主要的参数</span></span><br><span class=\"line\"><span class=\"comment\"># url -&gt; /</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])    # UrlPath, HttpMethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    <span class=\"comment\"># 我们知道python函数可以返回多个值, 在调用方会被组包成元组.</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里的返回值格式一般为: str_data, status_code, headers(dict)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello FLask&quot;</span>, <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># url -&gt; /json/ | /json(访问这个url时, 会被转发)</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/json/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">json</span>():</span></span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    resp = jsonify(data)    <span class=\"comment\"># jsonify 返回一个 Flask Reponse 实例</span></span><br><span class=\"line\">    resp.status_code = <span class=\"number\">200</span>  <span class=\"comment\"># 设置状态码</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>  resp</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>上面的代码就实现了一个简单的api接口, 由于Flask诞生的比较晚, 所以api 也比较现代化.<br>它希望大部分情况下, 都当作flask 视图函数都当作api来使用.</p>\n</li>\n<li><p>Flask 依赖项:</p>\n<ol>\n<li>提供web开发所需的 Werkzeug wsgi工具箱(提供flask 处理web开发常用的工具)</li>\n<li>jinjia2 模板引擎用来渲染模板</li>\n</ol>\n</li>\n<li><p>web服务器:<br>  Gunicorn 部署</p>\n</li>\n</ul>\n<p>比起的其它的web框架动则几个十几个的依赖简直不要太爽, 自己学习起来也比较舒服.</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><ul>\n<li><p>Flask 是一个python世界的微框架, 由于python语言的web服务器一般都是和web框架分离的.<br>现在就来看看它有多么微</p>\n</li>\n<li><p>pip install flask  </p>\n</li>\n<li><p>创建一个python 脚本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实例化 Flask app 对象 </span></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过app的route 装饰器将函数变成视图函数, 主要的参数</span></span><br><span class=\"line\"><span class=\"comment\"># url -&gt; /</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])    # UrlPath, HttpMethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    <span class=\"comment\"># 我们知道python函数可以返回多个值, 在调用方会被组包成元组.</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里的返回值格式一般为: str_data, status_code, headers(dict)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello FLask&quot;</span>, <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># url -&gt; /json/ | /json(访问这个url时, 会被转发)</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/json/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">json</span>():</span></span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    resp = jsonify(data)    <span class=\"comment\"># jsonify 返回一个 Flask Reponse 实例</span></span><br><span class=\"line\">    resp.status_code = <span class=\"number\">200</span>  <span class=\"comment\"># 设置状态码</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>  resp</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>上面的代码就实现了一个简单的api接口, 由于Flask诞生的比较晚, 所以api 也比较现代化.<br>它希望大部分情况下, 都当作flask 视图函数都当作api来使用.</p>\n</li>\n<li><p>Flask 依赖项:</p>\n<ol>\n<li>提供web开发所需的 Werkzeug wsgi工具箱(提供flask 处理web开发常用的工具)</li>\n<li>jinjia2 模板引擎用来渲染模板</li>\n</ol>\n</li>\n<li><p>web服务器:<br>  Gunicorn 部署</p>\n</li>\n</ul>\n<p>比起的其它的web框架动则几个十几个的依赖简直不要太爽, 自己学习起来也比较舒服.</p>\n"},{"title":"Flask shell 的便利性","date":"2017-10-09T16:04:46.000Z","_content":"### Flask 中的shell 工具\n\n1. flask cmd 工具\n\n* 将app 所在的脚本文件设置到环境变量中\n```\nset FLASK_APP=.\\path\\app.py\n```\n\n* 使用 flask run 可以直接运行flask 提供的开发服务器\n```\nflask run \n-h \"host\"\n-p port\n--cert path 用来使用https协议的证书路径\n```\n另一个好用的工具就是 routes\n* flask routes 可以得到项目的所有路由信息\n```\nflask routes\n```\n\n* flask shell 用来在命令行完成一些测试型的操作, 比如获取模型实例, 或者执行一小段flask程序代码\n```\nflask shell\n```\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n1. flask cli\n我们在使用migrate 的时候, 会发现安装扩展之后提供migrate命令, 而这个命令是怎么加入的呢\n```python\nimport click\nfrom flask import Flask\n\n\napp = Flask(__name__)\n\n\n@app.cli.command(\"create_user\")\n@click.argument(\"name\")\ndef create_user(name):\n    \n    print(name)\n\n```\n通过app.cli.command 装饰完成命令添加, 参数由click处理. 注意需要设置FLASK_APP环境变量, 不然无法成功.\n最后善用工具你的效率会变得比别人快的多","source":"_posts/Flask-shell-的便利性.md","raw":"---\ntitle: Flask shell 的便利性\ndate: 2017-10-10 00:04:46\ntags: Flask\n---\n### Flask 中的shell 工具\n\n1. flask cmd 工具\n\n* 将app 所在的脚本文件设置到环境变量中\n```\nset FLASK_APP=.\\path\\app.py\n```\n\n* 使用 flask run 可以直接运行flask 提供的开发服务器\n```\nflask run \n-h \"host\"\n-p port\n--cert path 用来使用https协议的证书路径\n```\n另一个好用的工具就是 routes\n* flask routes 可以得到项目的所有路由信息\n```\nflask routes\n```\n\n* flask shell 用来在命令行完成一些测试型的操作, 比如获取模型实例, 或者执行一小段flask程序代码\n```\nflask shell\n```\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n1. flask cli\n我们在使用migrate 的时候, 会发现安装扩展之后提供migrate命令, 而这个命令是怎么加入的呢\n```python\nimport click\nfrom flask import Flask\n\n\napp = Flask(__name__)\n\n\n@app.cli.command(\"create_user\")\n@click.argument(\"name\")\ndef create_user(name):\n    \n    print(name)\n\n```\n通过app.cli.command 装饰完成命令添加, 参数由click处理. 注意需要设置FLASK_APP环境变量, 不然无法成功.\n最后善用工具你的效率会变得比别人快的多","slug":"Flask-shell-的便利性","published":1,"updated":"2020-11-03T14:07:06.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjda0003o8t2fm8ofp6w","content":"<h3 id=\"Flask-中的shell-工具\"><a href=\"#Flask-中的shell-工具\" class=\"headerlink\" title=\"Flask 中的shell 工具\"></a>Flask 中的shell 工具</h3><ol>\n<li>flask cmd 工具</li>\n</ol>\n<ul>\n<li><p>将app 所在的脚本文件设置到环境变量中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set FLASK_APP&#x3D;.\\path\\app.py</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 flask run 可以直接运行flask 提供的开发服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flask run </span><br><span class=\"line\">-h &quot;host&quot;</span><br><span class=\"line\">-p port</span><br><span class=\"line\">--cert path 用来使用https协议的证书路径</span><br></pre></td></tr></table></figure>\n<p>另一个好用的工具就是 routes</p>\n</li>\n<li><p>flask routes 可以得到项目的所有路由信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flask routes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flask shell 用来在命令行完成一些测试型的操作, 比如获取模型实例, 或者执行一小段flask程序代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flask shell</span><br></pre></td></tr></table></figure>\n<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4></li>\n</ul>\n<ol>\n<li>flask cli<br>我们在使用migrate 的时候, 会发现安装扩展之后提供migrate命令, 而这个命令是怎么加入的呢<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> click</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.cli.command(&quot;create_user&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@click.argument(&quot;name&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_user</span>(<span class=\"params\">name</span>):</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    print(name)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n通过app.cli.command 装饰完成命令添加, 参数由click处理. 注意需要设置FLASK_APP环境变量, 不然无法成功.<br>最后善用工具你的效率会变得比别人快的多</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Flask-中的shell-工具\"><a href=\"#Flask-中的shell-工具\" class=\"headerlink\" title=\"Flask 中的shell 工具\"></a>Flask 中的shell 工具</h3><ol>\n<li>flask cmd 工具</li>\n</ol>\n<ul>\n<li><p>将app 所在的脚本文件设置到环境变量中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set FLASK_APP&#x3D;.\\path\\app.py</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 flask run 可以直接运行flask 提供的开发服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flask run </span><br><span class=\"line\">-h &quot;host&quot;</span><br><span class=\"line\">-p port</span><br><span class=\"line\">--cert path 用来使用https协议的证书路径</span><br></pre></td></tr></table></figure>\n<p>另一个好用的工具就是 routes</p>\n</li>\n<li><p>flask routes 可以得到项目的所有路由信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flask routes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flask shell 用来在命令行完成一些测试型的操作, 比如获取模型实例, 或者执行一小段flask程序代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flask shell</span><br></pre></td></tr></table></figure>\n<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4></li>\n</ul>\n<ol>\n<li>flask cli<br>我们在使用migrate 的时候, 会发现安装扩展之后提供migrate命令, 而这个命令是怎么加入的呢<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> click</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.cli.command(&quot;create_user&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@click.argument(&quot;name&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_user</span>(<span class=\"params\">name</span>):</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    print(name)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n通过app.cli.command 装饰完成命令添加, 参数由click处理. 注意需要设置FLASK_APP环境变量, 不然无法成功.<br>最后善用工具你的效率会变得比别人快的多</li>\n</ol>\n"},{"title":"Flask-sqlalchemy 使用","date":"2017-10-10T05:00:01.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### Flask-Sqlalchemy 通过扩展Sqlalchemy 在Flask中引入完善的ORM功能\nORM 是一种工具思想, 不管在哪个语言里面基本上都是通过映射元数据和表, 字段类型, 建立关联.\n而Sqlalchemy 是python世界比较出色的orm框架, 在设计上很多地方都借鉴了Java Hibernate的设计思想. 所以在很多地方它们都具有共同性.\n现在看看Flask-Sqlalchemy 对Mysql 的操作, 首先在你的虚拟环境中安装依赖\n\n1. pip install flask-sqlalchemy\n2. pip install pymysql\n\n```python\nfrom flask import Flask\nfrom flask_sqlalchemy import Sqlalchemy\n\napp = Flask(__name__)   # 实例化app\n\n# sqlalchemy config\napp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://username:password@host:port/dbname'\napp.config['SQLALCHEMY_ECHO'] = True    # 用来显示每次对数据库的操作\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True     # 这个参数需要占用过多的内存来支持Flask-sqlalchemy 所提供的信号， 可以根据业务需要调整\napp.config['SQLALCHEMY_BINDS'] = {}     # 多数据库字典用来实现连接多个数据库    {db1 : db_url, db2: db_url}\napp.config['SQLALCHEMY_ENGINE_OPTIONS'] = {}    # 如果使用MySQLdb 可以在这里传递 creater 并利用eventlet 的功能\n# conn pool config\napp.config['SQLALCHEMY_POOL_SIZE'] = 5  # default 5\napp.config['SQLALCHEMY_POOL_TIMEOUT'] = 1 # second\napp.config['SQLALCHEMY_POOL_RECYCLE'] = 3600 # second 连接超时时间\napp.config['SQLALCHEMY_MAX_OVERFLOW'] = 10 # 连接池被占用之后, 所有能溢出申请的连接数量\n\n\ndb = Sqlalchemy(app)    \n\n# 定义模型类\nclass User(db.Model):\n    __tablename__ = 'user'\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    name = db.Column(db.String(255), unique=True)\n\n# 然后我们就可以通过模型类和 db 对数据库进行操作\n# add\nuser = User(name='test')\n# 将用户模型实例add这次数据库会话中， db.session 是线程安全的\n\ndb.session.add(user)\ndb.session.commit()\n\n# select\nUser.query.filter(User.id == 1).first()  # 通过模型类查询, 一般简单的查询都可以通过模型类完成, 不存在返回None\ndb.session.query(User).filter(User.id == 1).first()  # 通过db 连接完成查询, 一般会有一些复杂的操作, 比如多表join, 应该考虑使用db, 并封装在model层面\n\n# update\nUser.query.filter()\nuser.name = 'test1'\ndb.session.add(user)\ndb.session.commit()\n\n# update tablename set field=value where conditions...\nuser = User.query.filter().update({\"field\": \"value\"})\ndb.session.commit()\n\n# delete\ndb.session.delete(user)\n\n# 对于查询语句还有更多的操作, 我会放在另一篇文章中描述\n```\n","source":"_posts/Flask-sqlalchemy-使用.md","raw":"---\ntitle: Flask-sqlalchemy 使用\ndate: 2017-10-10 13:00:01\ntags: Flask, Sqlalchemy, db\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### Flask-Sqlalchemy 通过扩展Sqlalchemy 在Flask中引入完善的ORM功能\nORM 是一种工具思想, 不管在哪个语言里面基本上都是通过映射元数据和表, 字段类型, 建立关联.\n而Sqlalchemy 是python世界比较出色的orm框架, 在设计上很多地方都借鉴了Java Hibernate的设计思想. 所以在很多地方它们都具有共同性.\n现在看看Flask-Sqlalchemy 对Mysql 的操作, 首先在你的虚拟环境中安装依赖\n\n1. pip install flask-sqlalchemy\n2. pip install pymysql\n\n```python\nfrom flask import Flask\nfrom flask_sqlalchemy import Sqlalchemy\n\napp = Flask(__name__)   # 实例化app\n\n# sqlalchemy config\napp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://username:password@host:port/dbname'\napp.config['SQLALCHEMY_ECHO'] = True    # 用来显示每次对数据库的操作\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True     # 这个参数需要占用过多的内存来支持Flask-sqlalchemy 所提供的信号， 可以根据业务需要调整\napp.config['SQLALCHEMY_BINDS'] = {}     # 多数据库字典用来实现连接多个数据库    {db1 : db_url, db2: db_url}\napp.config['SQLALCHEMY_ENGINE_OPTIONS'] = {}    # 如果使用MySQLdb 可以在这里传递 creater 并利用eventlet 的功能\n# conn pool config\napp.config['SQLALCHEMY_POOL_SIZE'] = 5  # default 5\napp.config['SQLALCHEMY_POOL_TIMEOUT'] = 1 # second\napp.config['SQLALCHEMY_POOL_RECYCLE'] = 3600 # second 连接超时时间\napp.config['SQLALCHEMY_MAX_OVERFLOW'] = 10 # 连接池被占用之后, 所有能溢出申请的连接数量\n\n\ndb = Sqlalchemy(app)    \n\n# 定义模型类\nclass User(db.Model):\n    __tablename__ = 'user'\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    name = db.Column(db.String(255), unique=True)\n\n# 然后我们就可以通过模型类和 db 对数据库进行操作\n# add\nuser = User(name='test')\n# 将用户模型实例add这次数据库会话中， db.session 是线程安全的\n\ndb.session.add(user)\ndb.session.commit()\n\n# select\nUser.query.filter(User.id == 1).first()  # 通过模型类查询, 一般简单的查询都可以通过模型类完成, 不存在返回None\ndb.session.query(User).filter(User.id == 1).first()  # 通过db 连接完成查询, 一般会有一些复杂的操作, 比如多表join, 应该考虑使用db, 并封装在model层面\n\n# update\nUser.query.filter()\nuser.name = 'test1'\ndb.session.add(user)\ndb.session.commit()\n\n# update tablename set field=value where conditions...\nuser = User.query.filter().update({\"field\": \"value\"})\ndb.session.commit()\n\n# delete\ndb.session.delete(user)\n\n# 对于查询语句还有更多的操作, 我会放在另一篇文章中描述\n```\n","slug":"Flask-sqlalchemy-使用","published":1,"updated":"2020-11-03T14:07:06.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdh0006o8t2di75ewp0","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"Flask-Sqlalchemy-通过扩展Sqlalchemy-在Flask中引入完善的ORM功能\"><a href=\"#Flask-Sqlalchemy-通过扩展Sqlalchemy-在Flask中引入完善的ORM功能\" class=\"headerlink\" title=\"Flask-Sqlalchemy 通过扩展Sqlalchemy 在Flask中引入完善的ORM功能\"></a>Flask-Sqlalchemy 通过扩展Sqlalchemy 在Flask中引入完善的ORM功能</h4><p>ORM 是一种工具思想, 不管在哪个语言里面基本上都是通过映射元数据和表, 字段类型, 建立关联.<br>而Sqlalchemy 是python世界比较出色的orm框架, 在设计上很多地方都借鉴了Java Hibernate的设计思想. 所以在很多地方它们都具有共同性.<br>现在看看Flask-Sqlalchemy 对Mysql 的操作, 首先在你的虚拟环境中安装依赖</p>\n<ol>\n<li>pip install flask-sqlalchemy</li>\n<li>pip install pymysql</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> Sqlalchemy</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)   <span class=\"comment\"># 实例化app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sqlalchemy config</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class=\"string\">&#x27;mysql+pymysql://username:password@host:port/dbname&#x27;</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class=\"literal\">True</span>    <span class=\"comment\"># 用来显示每次对数据库的操作</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class=\"literal\">True</span>     <span class=\"comment\"># 这个参数需要占用过多的内存来支持Flask-sqlalchemy 所提供的信号， 可以根据业务需要调整</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_BINDS&#x27;</span>] = &#123;&#125;     <span class=\"comment\"># 多数据库字典用来实现连接多个数据库    &#123;db1 : db_url, db2: db_url&#125;</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_ENGINE_OPTIONS&#x27;</span>] = &#123;&#125;    <span class=\"comment\"># 如果使用MySQLdb 可以在这里传递 creater 并利用eventlet 的功能</span></span><br><span class=\"line\"><span class=\"comment\"># conn pool config</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_POOL_SIZE&#x27;</span>] = <span class=\"number\">5</span>  <span class=\"comment\"># default 5</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_POOL_TIMEOUT&#x27;</span>] = <span class=\"number\">1</span> <span class=\"comment\"># second</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_POOL_RECYCLE&#x27;</span>] = <span class=\"number\">3600</span> <span class=\"comment\"># second 连接超时时间</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_MAX_OVERFLOW&#x27;</span>] = <span class=\"number\">10</span> <span class=\"comment\"># 连接池被占用之后, 所有能溢出申请的连接数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">db = Sqlalchemy(app)    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义模型类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">db.Model</span>):</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">&#x27;user&#x27;</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"literal\">True</span>, autoincrement=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    name = db.Column(db.String(<span class=\"number\">255</span>), unique=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后我们就可以通过模型类和 db 对数据库进行操作</span></span><br><span class=\"line\"><span class=\"comment\"># add</span></span><br><span class=\"line\">user = User(name=<span class=\"string\">&#x27;test&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 将用户模型实例add这次数据库会话中， db.session 是线程安全的</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.session.add(user)</span><br><span class=\"line\">db.session.commit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># select</span></span><br><span class=\"line\">User.query.filter(User.id == <span class=\"number\">1</span>).first()  <span class=\"comment\"># 通过模型类查询, 一般简单的查询都可以通过模型类完成, 不存在返回None</span></span><br><span class=\"line\">db.session.query(User).filter(User.id == <span class=\"number\">1</span>).first()  <span class=\"comment\"># 通过db 连接完成查询, 一般会有一些复杂的操作, 比如多表join, 应该考虑使用db, 并封装在model层面</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># update</span></span><br><span class=\"line\">User.query.filter()</span><br><span class=\"line\">user.name = <span class=\"string\">&#x27;test1&#x27;</span></span><br><span class=\"line\">db.session.add(user)</span><br><span class=\"line\">db.session.commit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># update tablename set field=value where conditions...</span></span><br><span class=\"line\">user = User.query.filter().update(&#123;<span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;value&quot;</span>&#125;)</span><br><span class=\"line\">db.session.commit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># delete</span></span><br><span class=\"line\">db.session.delete(user)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对于查询语句还有更多的操作, 我会放在另一篇文章中描述</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"Flask-Sqlalchemy-通过扩展Sqlalchemy-在Flask中引入完善的ORM功能\"><a href=\"#Flask-Sqlalchemy-通过扩展Sqlalchemy-在Flask中引入完善的ORM功能\" class=\"headerlink\" title=\"Flask-Sqlalchemy 通过扩展Sqlalchemy 在Flask中引入完善的ORM功能\"></a>Flask-Sqlalchemy 通过扩展Sqlalchemy 在Flask中引入完善的ORM功能</h4><p>ORM 是一种工具思想, 不管在哪个语言里面基本上都是通过映射元数据和表, 字段类型, 建立关联.<br>而Sqlalchemy 是python世界比较出色的orm框架, 在设计上很多地方都借鉴了Java Hibernate的设计思想. 所以在很多地方它们都具有共同性.<br>现在看看Flask-Sqlalchemy 对Mysql 的操作, 首先在你的虚拟环境中安装依赖</p>\n<ol>\n<li>pip install flask-sqlalchemy</li>\n<li>pip install pymysql</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> Sqlalchemy</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)   <span class=\"comment\"># 实例化app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sqlalchemy config</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class=\"string\">&#x27;mysql+pymysql://username:password@host:port/dbname&#x27;</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class=\"literal\">True</span>    <span class=\"comment\"># 用来显示每次对数据库的操作</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class=\"literal\">True</span>     <span class=\"comment\"># 这个参数需要占用过多的内存来支持Flask-sqlalchemy 所提供的信号， 可以根据业务需要调整</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_BINDS&#x27;</span>] = &#123;&#125;     <span class=\"comment\"># 多数据库字典用来实现连接多个数据库    &#123;db1 : db_url, db2: db_url&#125;</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_ENGINE_OPTIONS&#x27;</span>] = &#123;&#125;    <span class=\"comment\"># 如果使用MySQLdb 可以在这里传递 creater 并利用eventlet 的功能</span></span><br><span class=\"line\"><span class=\"comment\"># conn pool config</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_POOL_SIZE&#x27;</span>] = <span class=\"number\">5</span>  <span class=\"comment\"># default 5</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_POOL_TIMEOUT&#x27;</span>] = <span class=\"number\">1</span> <span class=\"comment\"># second</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_POOL_RECYCLE&#x27;</span>] = <span class=\"number\">3600</span> <span class=\"comment\"># second 连接超时时间</span></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_MAX_OVERFLOW&#x27;</span>] = <span class=\"number\">10</span> <span class=\"comment\"># 连接池被占用之后, 所有能溢出申请的连接数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">db = Sqlalchemy(app)    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义模型类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\">db.Model</span>):</span></span><br><span class=\"line\">    __tablename__ = <span class=\"string\">&#x27;user&#x27;</span></span><br><span class=\"line\">    id = db.Column(db.Integer, primary_key=<span class=\"literal\">True</span>, autoincrement=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    name = db.Column(db.String(<span class=\"number\">255</span>), unique=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后我们就可以通过模型类和 db 对数据库进行操作</span></span><br><span class=\"line\"><span class=\"comment\"># add</span></span><br><span class=\"line\">user = User(name=<span class=\"string\">&#x27;test&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 将用户模型实例add这次数据库会话中， db.session 是线程安全的</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.session.add(user)</span><br><span class=\"line\">db.session.commit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># select</span></span><br><span class=\"line\">User.query.filter(User.id == <span class=\"number\">1</span>).first()  <span class=\"comment\"># 通过模型类查询, 一般简单的查询都可以通过模型类完成, 不存在返回None</span></span><br><span class=\"line\">db.session.query(User).filter(User.id == <span class=\"number\">1</span>).first()  <span class=\"comment\"># 通过db 连接完成查询, 一般会有一些复杂的操作, 比如多表join, 应该考虑使用db, 并封装在model层面</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># update</span></span><br><span class=\"line\">User.query.filter()</span><br><span class=\"line\">user.name = <span class=\"string\">&#x27;test1&#x27;</span></span><br><span class=\"line\">db.session.add(user)</span><br><span class=\"line\">db.session.commit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># update tablename set field=value where conditions...</span></span><br><span class=\"line\">user = User.query.filter().update(&#123;<span class=\"string\">&quot;field&quot;</span>: <span class=\"string\">&quot;value&quot;</span>&#125;)</span><br><span class=\"line\">db.session.commit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># delete</span></span><br><span class=\"line\">db.session.delete(user)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对于查询语句还有更多的操作, 我会放在另一篇文章中描述</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Flask 中日志的处理","date":"2017-10-11T15:23:12.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask 日志处理\n\nflask 中默认处理了日志的内容, 在日志使用中通过 current_app 调用使用. ","source":"_posts/Flask-中日志的处理.md","raw":"---\ntitle: Flask 中日志的处理\ndate: 2017-10-11 23:23:12\ntags: Flask, logging\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask 日志处理\n\nflask 中默认处理了日志的内容, 在日志使用中通过 current_app 调用使用. ","slug":"Flask-中日志的处理","published":1,"updated":"2020-11-03T14:07:06.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdn0008o8t20vuk8vu9","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-日志处理\"><a href=\"#Flask-日志处理\" class=\"headerlink\" title=\"Flask 日志处理\"></a>Flask 日志处理</h2><p>flask 中默认处理了日志的内容, 在日志使用中通过 current_app 调用使用. </p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-日志处理\"><a href=\"#Flask-日志处理\" class=\"headerlink\" title=\"Flask 日志处理\"></a>Flask 日志处理</h2><p>flask 中默认处理了日志的内容, 在日志使用中通过 current_app 调用使用. </p>\n"},{"title":"Flask处理请求","date":"2017-10-10T14:43:23.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n\n##### Flask 中处理请求\n\n在常见的web开发后端中, 我们一般都需要围绕请求和响应来处理业务逻辑.\n哪么我们就需要对http请求和响应进行处理, Flask给我们提供了一系列的工具函数\n\n* request\n    request 是Flask 对http请求信息的封装, 目的就是让我们很便利的访问http请求信息\n    常见的请求参数, 请求头, 请求体数据, 上传文件... 等等场景下, 实现快速实现业务.\n    \n* session\n    在服务端保存用户凭证的技术, 通过在cookie 中存放对应的sessionId 与服务器上的session对应\n    主要用来保存用户状态, 在Flask-session 扩展中实现了不同存储后端, 比如redis, db, file.\n    \n* jsonify\n    对响应数据进行json格式化, 能够序列化json所支持的数据类型\n\n* make_response\n    内部其实是一个多分支判断, 但主要功能是生成不同类型响应对象\n    \n总结:\n通过上面Flask 所提供的工具函数, 我们可以快速完成业务. 但是也存在一些问题:\n\n* 对不支持json的类型, Flask并没有处理, 还需要我们自己手动处理. 主要在jsonEncode和jsonDecode这一块.\n* 需要自己封装验证逻辑\n* 语法太过灵活, 会让新手很选择难选择\n","source":"_posts/Flask-中请求的处理.md","raw":"---\ntitle: Flask处理请求\ndate: 2017-10-10 22:43:23\ntags: Flask\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n\n##### Flask 中处理请求\n\n在常见的web开发后端中, 我们一般都需要围绕请求和响应来处理业务逻辑.\n哪么我们就需要对http请求和响应进行处理, Flask给我们提供了一系列的工具函数\n\n* request\n    request 是Flask 对http请求信息的封装, 目的就是让我们很便利的访问http请求信息\n    常见的请求参数, 请求头, 请求体数据, 上传文件... 等等场景下, 实现快速实现业务.\n    \n* session\n    在服务端保存用户凭证的技术, 通过在cookie 中存放对应的sessionId 与服务器上的session对应\n    主要用来保存用户状态, 在Flask-session 扩展中实现了不同存储后端, 比如redis, db, file.\n    \n* jsonify\n    对响应数据进行json格式化, 能够序列化json所支持的数据类型\n\n* make_response\n    内部其实是一个多分支判断, 但主要功能是生成不同类型响应对象\n    \n总结:\n通过上面Flask 所提供的工具函数, 我们可以快速完成业务. 但是也存在一些问题:\n\n* 对不支持json的类型, Flask并没有处理, 还需要我们自己手动处理. 主要在jsonEncode和jsonDecode这一块.\n* 需要自己封装验证逻辑\n* 语法太过灵活, 会让新手很选择难选择\n","slug":"Flask-中请求的处理","published":1,"updated":"2020-11-03T14:07:06.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdq000ao8t23zg18kl1","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h5 id=\"Flask-中处理请求\"><a href=\"#Flask-中处理请求\" class=\"headerlink\" title=\"Flask 中处理请求\"></a>Flask 中处理请求</h5><p>在常见的web开发后端中, 我们一般都需要围绕请求和响应来处理业务逻辑.<br>哪么我们就需要对http请求和响应进行处理, Flask给我们提供了一系列的工具函数</p>\n<ul>\n<li><p>request<br>  request 是Flask 对http请求信息的封装, 目的就是让我们很便利的访问http请求信息<br>  常见的请求参数, 请求头, 请求体数据, 上传文件… 等等场景下, 实现快速实现业务.</p>\n</li>\n<li><p>session<br>  在服务端保存用户凭证的技术, 通过在cookie 中存放对应的sessionId 与服务器上的session对应<br>  主要用来保存用户状态, 在Flask-session 扩展中实现了不同存储后端, 比如redis, db, file.</p>\n</li>\n<li><p>jsonify<br>  对响应数据进行json格式化, 能够序列化json所支持的数据类型</p>\n</li>\n<li><p>make_response<br>  内部其实是一个多分支判断, 但主要功能是生成不同类型响应对象</p>\n</li>\n</ul>\n<p>总结:<br>通过上面Flask 所提供的工具函数, 我们可以快速完成业务. 但是也存在一些问题:</p>\n<ul>\n<li>对不支持json的类型, Flask并没有处理, 还需要我们自己手动处理. 主要在jsonEncode和jsonDecode这一块.</li>\n<li>需要自己封装验证逻辑</li>\n<li>语法太过灵活, 会让新手很选择难选择</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h5 id=\"Flask-中处理请求\"><a href=\"#Flask-中处理请求\" class=\"headerlink\" title=\"Flask 中处理请求\"></a>Flask 中处理请求</h5><p>在常见的web开发后端中, 我们一般都需要围绕请求和响应来处理业务逻辑.<br>哪么我们就需要对http请求和响应进行处理, Flask给我们提供了一系列的工具函数</p>\n<ul>\n<li><p>request<br>  request 是Flask 对http请求信息的封装, 目的就是让我们很便利的访问http请求信息<br>  常见的请求参数, 请求头, 请求体数据, 上传文件… 等等场景下, 实现快速实现业务.</p>\n</li>\n<li><p>session<br>  在服务端保存用户凭证的技术, 通过在cookie 中存放对应的sessionId 与服务器上的session对应<br>  主要用来保存用户状态, 在Flask-session 扩展中实现了不同存储后端, 比如redis, db, file.</p>\n</li>\n<li><p>jsonify<br>  对响应数据进行json格式化, 能够序列化json所支持的数据类型</p>\n</li>\n<li><p>make_response<br>  内部其实是一个多分支判断, 但主要功能是生成不同类型响应对象</p>\n</li>\n</ul>\n<p>总结:<br>通过上面Flask 所提供的工具函数, 我们可以快速完成业务. 但是也存在一些问题:</p>\n<ul>\n<li>对不支持json的类型, Flask并没有处理, 还需要我们自己手动处理. 主要在jsonEncode和jsonDecode这一块.</li>\n<li>需要自己封装验证逻辑</li>\n<li>语法太过灵活, 会让新手很选择难选择</li>\n</ul>\n"},{"title":"Flask 信号","date":"2017-10-12T14:48:54.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask 信号机制\n\n在大型的应用中, 随着业务越来越复杂, 代码的耦合读就会上升. 这时候我们就需要一些手段对复杂的业务解耦\n根据Flask 框架所提供的能力, 可以通过Signal机制, 简单代码如下\n\n```python\nfrom flask import Flask, jsonify\n\nfrom blinker import Namespace\n\n# 创建信号\nmodel_signal = Namespace()\n\nmodel_saved = model_signal.signal('model-signal')\n\napp = Flask(__name__)\n\napp.config['DEBUG'] = True\n\n\nclass LuckyModel:\n\n    def __init__(self):\n        self.data = {}\n\n    def save(self, id, name):\n        self.data[id] = name\n        # 根据每个函数执行的返回值, 可以确定函数的执行状态\n        ret = model_saved.send(self, id, name)\n        for res, sate in ret:\n            # 如果返回值为False 证明函数是执行是失败的\n            if not sate:\n                res(id, name)\n\n\nmodel = LuckyModel()\n\n\n@model_saved.connect_via(model)\ndef add_balance(sender, **kwargs):\n    print(sender, '\\t', **kwargs)\n    print(\"add balance 执行了\")\n\n\n@model_saved.connect_via(model)\ndef add_log(sender, **kwargs):\n    print(sender, '\\t', **kwargs)\n    print(\"add log 执行了\")\n\n\n@app.route('/', methods=['GET', ])\ndef index():\n    resp = jsonify({'data': \"this is index page\"})\n    model.save(1, 'edges')\n    resp.status_code = 200\n    return resp\n\n\nif __name__ == '__main__':\n    app.run()\n\n\n```\n当 model.save() 执行时, model_signal触发, 就会通知订阅的函数, 执行相关操作, 并返回订阅的函数和函数的返回结果.\n如果现在有一个订单业务需要在提交之前创建一个订单流水记录,正常的操作是在一个事务中创建一张流水记录, 紧接着创建订单表.\n1. transaction begin\n2. 创建order\n3. insert data\n4. update data\n5. 创建order invoice\n6. insert data\n7.transaction end\n但是现在我要求对创建订单后还要创建其它的数据呢, 哪么我们又要在代码里面修改吗? 遵循代码设计的开放封闭原则, 对已经完成的代码原则上不应该直接修改.\n除非由重构的需要, 哪么这地方引入信号的机制的好处就很明显了.\n\n```python \n# 要在订单之后发送信号, 注意这个地方会返回订阅函数的执行结果和订阅函数\n# 所以根据返回结果来决定代码流程.\n# 注意第一位位置参数应该是发送者\nret = Signal().send(sender, **kwargs)\n```\n哪么解决了代码耦合的问题, 对于函数执行失败的操作我们该如何处理, 并且要保证这些操作在一个事务里面. 失败好处理, 在代码流程中捕获并返回给发送者即可.哪么事务呢?\n答案在flask_sqlalchemy源码里面, 当我们在request_context中调用的db.session都是一个, 因为request_context, 是在当前app_context 被推入stack中才有的\n\n```python\n def create_scoped_session(self, options=None):\n        if options is None:\n            options = {}\n        \n        # _app_ctx_stack 代表着当前应用的上下文, 对于每个请求来讲它是线程安全的, __ident_func__用来识别不同线程\n        scopefunc = options.pop('scopefunc', _app_ctx_stack.__ident_func__)\n        options.setdefault('query_cls', self.Query)\n        # 创建一个安全的session, 并设置scopefunc wei指定的左右域\n        return orm.scoped_session(\n            self.create_session(options), scopefunc=scopefunc\n        )\n```\n哪么在全局中我们的session是一个的话, 直接调用db.session完成会话上面的数据add, 注意不要commit(), 在发起信号之后进行commit(), 就能够保证订阅函数的数据库操作与\n业务函数的数据库操作在一个事务中.\n","source":"_posts/Flask-信号.md","raw":"---\ntitle: Flask 信号\ndate: 2017-10-12 22:48:54\ntags: Flask, Signal\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask 信号机制\n\n在大型的应用中, 随着业务越来越复杂, 代码的耦合读就会上升. 这时候我们就需要一些手段对复杂的业务解耦\n根据Flask 框架所提供的能力, 可以通过Signal机制, 简单代码如下\n\n```python\nfrom flask import Flask, jsonify\n\nfrom blinker import Namespace\n\n# 创建信号\nmodel_signal = Namespace()\n\nmodel_saved = model_signal.signal('model-signal')\n\napp = Flask(__name__)\n\napp.config['DEBUG'] = True\n\n\nclass LuckyModel:\n\n    def __init__(self):\n        self.data = {}\n\n    def save(self, id, name):\n        self.data[id] = name\n        # 根据每个函数执行的返回值, 可以确定函数的执行状态\n        ret = model_saved.send(self, id, name)\n        for res, sate in ret:\n            # 如果返回值为False 证明函数是执行是失败的\n            if not sate:\n                res(id, name)\n\n\nmodel = LuckyModel()\n\n\n@model_saved.connect_via(model)\ndef add_balance(sender, **kwargs):\n    print(sender, '\\t', **kwargs)\n    print(\"add balance 执行了\")\n\n\n@model_saved.connect_via(model)\ndef add_log(sender, **kwargs):\n    print(sender, '\\t', **kwargs)\n    print(\"add log 执行了\")\n\n\n@app.route('/', methods=['GET', ])\ndef index():\n    resp = jsonify({'data': \"this is index page\"})\n    model.save(1, 'edges')\n    resp.status_code = 200\n    return resp\n\n\nif __name__ == '__main__':\n    app.run()\n\n\n```\n当 model.save() 执行时, model_signal触发, 就会通知订阅的函数, 执行相关操作, 并返回订阅的函数和函数的返回结果.\n如果现在有一个订单业务需要在提交之前创建一个订单流水记录,正常的操作是在一个事务中创建一张流水记录, 紧接着创建订单表.\n1. transaction begin\n2. 创建order\n3. insert data\n4. update data\n5. 创建order invoice\n6. insert data\n7.transaction end\n但是现在我要求对创建订单后还要创建其它的数据呢, 哪么我们又要在代码里面修改吗? 遵循代码设计的开放封闭原则, 对已经完成的代码原则上不应该直接修改.\n除非由重构的需要, 哪么这地方引入信号的机制的好处就很明显了.\n\n```python \n# 要在订单之后发送信号, 注意这个地方会返回订阅函数的执行结果和订阅函数\n# 所以根据返回结果来决定代码流程.\n# 注意第一位位置参数应该是发送者\nret = Signal().send(sender, **kwargs)\n```\n哪么解决了代码耦合的问题, 对于函数执行失败的操作我们该如何处理, 并且要保证这些操作在一个事务里面. 失败好处理, 在代码流程中捕获并返回给发送者即可.哪么事务呢?\n答案在flask_sqlalchemy源码里面, 当我们在request_context中调用的db.session都是一个, 因为request_context, 是在当前app_context 被推入stack中才有的\n\n```python\n def create_scoped_session(self, options=None):\n        if options is None:\n            options = {}\n        \n        # _app_ctx_stack 代表着当前应用的上下文, 对于每个请求来讲它是线程安全的, __ident_func__用来识别不同线程\n        scopefunc = options.pop('scopefunc', _app_ctx_stack.__ident_func__)\n        options.setdefault('query_cls', self.Query)\n        # 创建一个安全的session, 并设置scopefunc wei指定的左右域\n        return orm.scoped_session(\n            self.create_session(options), scopefunc=scopefunc\n        )\n```\n哪么在全局中我们的session是一个的话, 直接调用db.session完成会话上面的数据add, 注意不要commit(), 在发起信号之后进行commit(), 就能够保证订阅函数的数据库操作与\n业务函数的数据库操作在一个事务中.\n","slug":"Flask-信号","published":1,"updated":"2020-11-03T14:07:06.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdu000eo8t2ephh7sy7","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-信号机制\"><a href=\"#Flask-信号机制\" class=\"headerlink\" title=\"Flask 信号机制\"></a>Flask 信号机制</h2><p>在大型的应用中, 随着业务越来越复杂, 代码的耦合读就会上升. 这时候我们就需要一些手段对复杂的业务解耦<br>根据Flask 框架所提供的能力, 可以通过Signal机制, 简单代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> blinker <span class=\"keyword\">import</span> Namespace</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建信号</span></span><br><span class=\"line\">model_signal = Namespace()</span><br><span class=\"line\"></span><br><span class=\"line\">model_saved = model_signal.signal(<span class=\"string\">&#x27;model-signal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;DEBUG&#x27;</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LuckyModel</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.data = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save</span>(<span class=\"params\">self, id, name</span>):</span></span><br><span class=\"line\">        self.data[id] = name</span><br><span class=\"line\">        <span class=\"comment\"># 根据每个函数执行的返回值, 可以确定函数的执行状态</span></span><br><span class=\"line\">        ret = model_saved.send(self, id, name)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> res, sate <span class=\"keyword\">in</span> ret:</span><br><span class=\"line\">            <span class=\"comment\"># 如果返回值为False 证明函数是执行是失败的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> sate:</span><br><span class=\"line\">                res(id, name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">model = LuckyModel()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@model_saved.connect_via(model)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_balance</span>(<span class=\"params\">sender, **kwargs</span>):</span></span><br><span class=\"line\">    print(sender, <span class=\"string\">&#x27;\\t&#x27;</span>, **kwargs)</span><br><span class=\"line\">    print(<span class=\"string\">&quot;add balance 执行了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@model_saved.connect_via(model)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_log</span>(<span class=\"params\">sender, **kwargs</span>):</span></span><br><span class=\"line\">    print(sender, <span class=\"string\">&#x27;\\t&#x27;</span>, **kwargs)</span><br><span class=\"line\">    print(<span class=\"string\">&quot;add log 执行了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, ])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    resp = jsonify(&#123;<span class=\"string\">&#x27;data&#x27;</span>: <span class=\"string\">&quot;this is index page&quot;</span>&#125;)</span><br><span class=\"line\">    model.save(<span class=\"number\">1</span>, <span class=\"string\">&#x27;edges&#x27;</span>)</span><br><span class=\"line\">    resp.status_code = <span class=\"number\">200</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> resp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当 model.save() 执行时, model_signal触发, 就会通知订阅的函数, 执行相关操作, 并返回订阅的函数和函数的返回结果.<br>如果现在有一个订单业务需要在提交之前创建一个订单流水记录,正常的操作是在一个事务中创建一张流水记录, 紧接着创建订单表.</p>\n<ol>\n<li>transaction begin</li>\n<li>创建order</li>\n<li>insert data</li>\n<li>update data</li>\n<li>创建order invoice</li>\n<li>insert data</li>\n<li>transaction end<br>但是现在我要求对创建订单后还要创建其它的数据呢, 哪么我们又要在代码里面修改吗? 遵循代码设计的开放封闭原则, 对已经完成的代码原则上不应该直接修改.<br>除非由重构的需要, 哪么这地方引入信号的机制的好处就很明显了.</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 要在订单之后发送信号, 注意这个地方会返回订阅函数的执行结果和订阅函数</span></span><br><span class=\"line\"><span class=\"comment\"># 所以根据返回结果来决定代码流程.</span></span><br><span class=\"line\"><span class=\"comment\"># 注意第一位位置参数应该是发送者</span></span><br><span class=\"line\">ret = Signal().send(sender, **kwargs)</span><br></pre></td></tr></table></figure>\n<p>哪么解决了代码耦合的问题, 对于函数执行失败的操作我们该如何处理, 并且要保证这些操作在一个事务里面. 失败好处理, 在代码流程中捕获并返回给发送者即可.哪么事务呢?<br>答案在flask_sqlalchemy源码里面, 当我们在request_context中调用的db.session都是一个, 因为request_context, 是在当前app_context 被推入stack中才有的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_scoped_session</span>(<span class=\"params\">self, options=None</span>):</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> options <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">           options = &#123;&#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\"># _app_ctx_stack 代表着当前应用的上下文, 对于每个请求来讲它是线程安全的, __ident_func__用来识别不同线程</span></span><br><span class=\"line\">       scopefunc = options.pop(<span class=\"string\">&#x27;scopefunc&#x27;</span>, _app_ctx_stack.__ident_func__)</span><br><span class=\"line\">       options.setdefault(<span class=\"string\">&#x27;query_cls&#x27;</span>, self.Query)</span><br><span class=\"line\">       <span class=\"comment\"># 创建一个安全的session, 并设置scopefunc wei指定的左右域</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> orm.scoped_session(</span><br><span class=\"line\">           self.create_session(options), scopefunc=scopefunc</span><br><span class=\"line\">       )</span><br></pre></td></tr></table></figure>\n<p>哪么在全局中我们的session是一个的话, 直接调用db.session完成会话上面的数据add, 注意不要commit(), 在发起信号之后进行commit(), 就能够保证订阅函数的数据库操作与<br>业务函数的数据库操作在一个事务中.</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-信号机制\"><a href=\"#Flask-信号机制\" class=\"headerlink\" title=\"Flask 信号机制\"></a>Flask 信号机制</h2><p>在大型的应用中, 随着业务越来越复杂, 代码的耦合读就会上升. 这时候我们就需要一些手段对复杂的业务解耦<br>根据Flask 框架所提供的能力, 可以通过Signal机制, 简单代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> blinker <span class=\"keyword\">import</span> Namespace</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建信号</span></span><br><span class=\"line\">model_signal = Namespace()</span><br><span class=\"line\"></span><br><span class=\"line\">model_saved = model_signal.signal(<span class=\"string\">&#x27;model-signal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;DEBUG&#x27;</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LuckyModel</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.data = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save</span>(<span class=\"params\">self, id, name</span>):</span></span><br><span class=\"line\">        self.data[id] = name</span><br><span class=\"line\">        <span class=\"comment\"># 根据每个函数执行的返回值, 可以确定函数的执行状态</span></span><br><span class=\"line\">        ret = model_saved.send(self, id, name)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> res, sate <span class=\"keyword\">in</span> ret:</span><br><span class=\"line\">            <span class=\"comment\"># 如果返回值为False 证明函数是执行是失败的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> sate:</span><br><span class=\"line\">                res(id, name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">model = LuckyModel()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@model_saved.connect_via(model)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_balance</span>(<span class=\"params\">sender, **kwargs</span>):</span></span><br><span class=\"line\">    print(sender, <span class=\"string\">&#x27;\\t&#x27;</span>, **kwargs)</span><br><span class=\"line\">    print(<span class=\"string\">&quot;add balance 执行了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@model_saved.connect_via(model)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_log</span>(<span class=\"params\">sender, **kwargs</span>):</span></span><br><span class=\"line\">    print(sender, <span class=\"string\">&#x27;\\t&#x27;</span>, **kwargs)</span><br><span class=\"line\">    print(<span class=\"string\">&quot;add log 执行了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, ])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    resp = jsonify(&#123;<span class=\"string\">&#x27;data&#x27;</span>: <span class=\"string\">&quot;this is index page&quot;</span>&#125;)</span><br><span class=\"line\">    model.save(<span class=\"number\">1</span>, <span class=\"string\">&#x27;edges&#x27;</span>)</span><br><span class=\"line\">    resp.status_code = <span class=\"number\">200</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> resp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当 model.save() 执行时, model_signal触发, 就会通知订阅的函数, 执行相关操作, 并返回订阅的函数和函数的返回结果.<br>如果现在有一个订单业务需要在提交之前创建一个订单流水记录,正常的操作是在一个事务中创建一张流水记录, 紧接着创建订单表.</p>\n<ol>\n<li>transaction begin</li>\n<li>创建order</li>\n<li>insert data</li>\n<li>update data</li>\n<li>创建order invoice</li>\n<li>insert data</li>\n<li>transaction end<br>但是现在我要求对创建订单后还要创建其它的数据呢, 哪么我们又要在代码里面修改吗? 遵循代码设计的开放封闭原则, 对已经完成的代码原则上不应该直接修改.<br>除非由重构的需要, 哪么这地方引入信号的机制的好处就很明显了.</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 要在订单之后发送信号, 注意这个地方会返回订阅函数的执行结果和订阅函数</span></span><br><span class=\"line\"><span class=\"comment\"># 所以根据返回结果来决定代码流程.</span></span><br><span class=\"line\"><span class=\"comment\"># 注意第一位位置参数应该是发送者</span></span><br><span class=\"line\">ret = Signal().send(sender, **kwargs)</span><br></pre></td></tr></table></figure>\n<p>哪么解决了代码耦合的问题, 对于函数执行失败的操作我们该如何处理, 并且要保证这些操作在一个事务里面. 失败好处理, 在代码流程中捕获并返回给发送者即可.哪么事务呢?<br>答案在flask_sqlalchemy源码里面, 当我们在request_context中调用的db.session都是一个, 因为request_context, 是在当前app_context 被推入stack中才有的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_scoped_session</span>(<span class=\"params\">self, options=None</span>):</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> options <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">           options = &#123;&#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\"># _app_ctx_stack 代表着当前应用的上下文, 对于每个请求来讲它是线程安全的, __ident_func__用来识别不同线程</span></span><br><span class=\"line\">       scopefunc = options.pop(<span class=\"string\">&#x27;scopefunc&#x27;</span>, _app_ctx_stack.__ident_func__)</span><br><span class=\"line\">       options.setdefault(<span class=\"string\">&#x27;query_cls&#x27;</span>, self.Query)</span><br><span class=\"line\">       <span class=\"comment\"># 创建一个安全的session, 并设置scopefunc wei指定的左右域</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> orm.scoped_session(</span><br><span class=\"line\">           self.create_session(options), scopefunc=scopefunc</span><br><span class=\"line\">       )</span><br></pre></td></tr></table></figure>\n<p>哪么在全局中我们的session是一个的话, 直接调用db.session完成会话上面的数据add, 注意不要commit(), 在发起信号之后进行commit(), 就能够保证订阅函数的数据库操作与<br>业务函数的数据库操作在一个事务中.</p>\n"},{"title":"Flask 钩子函数","date":"2017-10-13T14:48:46.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### Flask 钩子函数:\n\n在客户端和服务端网络交互的过程中, 有时需要对交互过程, 或者在交互前后,做一定的处理. 这个时候框架提供的接口就很重要了,\n一般我们可能称这些接口为中间件或者事件钩子. 就是像是你在学校想叫个外卖, 然后你又不能出去. 这个时候你就找个钩子放到墙外, 告诉老板, 把东西放在钩子上.\n哪么Flask 也为我们提供了一些钩子函数\n\n1. before_first_request\n    在第一次请求时触发\n\n2. after_request\n    在请求正常处理之后触发\n    \n3. before_request\n    在请求进入视图函数处理之前触发\n    \n4. teardown_request\n    在每次请求之后触发, 处理异常响应\n    \n使用方式也很简单, 就是装饰器一样\n\n```python\n    @app.before_request\n    def handler_request():\n        pass\n\n```\n注意 after_request 和 teardown_request 装饰的函数, 需要定义一个参数用来接收响应, 不然会出现问题.\n\n说完了Flask 提供给的钩子, 哪么我们具体来说一下它们的实际应用场景\n\nbefore_request 在请求进入视图函数之前做处理, 哪么我们想想, 哪些是需要在处理请求之前要做的事情.\n* 验证用户信息\n* 验证用户权限\n* 验证请求参数\n* 对请求头进行验证, 尤其是跨域中, 我们需要对指定的请求头做处理.\n* 甚至为用户request 的添加属性, 或者绑定方法\n\n而这些操作都需要或者间接需要对request 做处理哪么, 在使用时, 需要导入request\n```python\nfrom flask import Flask, request, make_response\n\napp = Flask(__name__)\n\nallowed_host = ['www.host.com']\n\n\n@app.before_request\ndef handler_cors_request():\n    \"\"\"\n        处理跨域问题\n    \"\"\"\n    origin = request.headers['origin']\n\n    if origin not in allowed_host:\n        return make_response()\n\n@app.after_request\ndef handler_cors_response(response):\n    \"\"\"\n        cors 最主要的是在返回响应时, 服务端告诉前端, 是否允许跨域, cookie能不能, headers 能不能跨域\n    \"\"\"\n    response.set_headers(\"Access-Control-Allow-Origin\", request.full_path)\n    response.set_headers(\"Access-Control-Allow-Credentials\", True)\n    response.set_headers(\"Content-Type\", \"application/json\")\n    \n```\n","source":"_posts/Flask-钩子函数.md","raw":"---\ntitle: Flask 钩子函数\ndate: 2017-10-13 22:48:46\ntags: Flask 钩子函数\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### Flask 钩子函数:\n\n在客户端和服务端网络交互的过程中, 有时需要对交互过程, 或者在交互前后,做一定的处理. 这个时候框架提供的接口就很重要了,\n一般我们可能称这些接口为中间件或者事件钩子. 就是像是你在学校想叫个外卖, 然后你又不能出去. 这个时候你就找个钩子放到墙外, 告诉老板, 把东西放在钩子上.\n哪么Flask 也为我们提供了一些钩子函数\n\n1. before_first_request\n    在第一次请求时触发\n\n2. after_request\n    在请求正常处理之后触发\n    \n3. before_request\n    在请求进入视图函数处理之前触发\n    \n4. teardown_request\n    在每次请求之后触发, 处理异常响应\n    \n使用方式也很简单, 就是装饰器一样\n\n```python\n    @app.before_request\n    def handler_request():\n        pass\n\n```\n注意 after_request 和 teardown_request 装饰的函数, 需要定义一个参数用来接收响应, 不然会出现问题.\n\n说完了Flask 提供给的钩子, 哪么我们具体来说一下它们的实际应用场景\n\nbefore_request 在请求进入视图函数之前做处理, 哪么我们想想, 哪些是需要在处理请求之前要做的事情.\n* 验证用户信息\n* 验证用户权限\n* 验证请求参数\n* 对请求头进行验证, 尤其是跨域中, 我们需要对指定的请求头做处理.\n* 甚至为用户request 的添加属性, 或者绑定方法\n\n而这些操作都需要或者间接需要对request 做处理哪么, 在使用时, 需要导入request\n```python\nfrom flask import Flask, request, make_response\n\napp = Flask(__name__)\n\nallowed_host = ['www.host.com']\n\n\n@app.before_request\ndef handler_cors_request():\n    \"\"\"\n        处理跨域问题\n    \"\"\"\n    origin = request.headers['origin']\n\n    if origin not in allowed_host:\n        return make_response()\n\n@app.after_request\ndef handler_cors_response(response):\n    \"\"\"\n        cors 最主要的是在返回响应时, 服务端告诉前端, 是否允许跨域, cookie能不能, headers 能不能跨域\n    \"\"\"\n    response.set_headers(\"Access-Control-Allow-Origin\", request.full_path)\n    response.set_headers(\"Access-Control-Allow-Credentials\", True)\n    response.set_headers(\"Content-Type\", \"application/json\")\n    \n```\n","slug":"Flask-钩子函数","published":1,"updated":"2020-11-03T14:07:06.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdw000ho8t28snm75gg","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"Flask-钩子函数\"><a href=\"#Flask-钩子函数\" class=\"headerlink\" title=\"Flask 钩子函数:\"></a>Flask 钩子函数:</h4><p>在客户端和服务端网络交互的过程中, 有时需要对交互过程, 或者在交互前后,做一定的处理. 这个时候框架提供的接口就很重要了,<br>一般我们可能称这些接口为中间件或者事件钩子. 就是像是你在学校想叫个外卖, 然后你又不能出去. 这个时候你就找个钩子放到墙外, 告诉老板, 把东西放在钩子上.<br>哪么Flask 也为我们提供了一些钩子函数</p>\n<ol>\n<li><p>before_first_request<br> 在第一次请求时触发</p>\n</li>\n<li><p>after_request<br> 在请求正常处理之后触发</p>\n</li>\n<li><p>before_request<br> 在请求进入视图函数处理之前触发</p>\n</li>\n<li><p>teardown_request<br> 在每次请求之后触发, 处理异常响应</p>\n</li>\n</ol>\n<p>使用方式也很简单, 就是装饰器一样</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@app.before_request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handler_request</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>注意 after_request 和 teardown_request 装饰的函数, 需要定义一个参数用来接收响应, 不然会出现问题.</p>\n<p>说完了Flask 提供给的钩子, 哪么我们具体来说一下它们的实际应用场景</p>\n<p>before_request 在请求进入视图函数之前做处理, 哪么我们想想, 哪些是需要在处理请求之前要做的事情.</p>\n<ul>\n<li>验证用户信息</li>\n<li>验证用户权限</li>\n<li>验证请求参数</li>\n<li>对请求头进行验证, 尤其是跨域中, 我们需要对指定的请求头做处理.</li>\n<li>甚至为用户request 的添加属性, 或者绑定方法</li>\n</ul>\n<p>而这些操作都需要或者间接需要对request 做处理哪么, 在使用时, 需要导入request</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, request, make_response</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">allowed_host = [<span class=\"string\">&#x27;www.host.com&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.before_request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handler_cors_request</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        处理跨域问题</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    origin = request.headers[<span class=\"string\">&#x27;origin&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> origin <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> allowed_host:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> make_response()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.after_request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handler_cors_response</span>(<span class=\"params\">response</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        cors 最主要的是在返回响应时, 服务端告诉前端, 是否允许跨域, cookie能不能, headers 能不能跨域</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    response.set_headers(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, request.full_path)</span><br><span class=\"line\">    response.set_headers(<span class=\"string\">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class=\"literal\">True</span>)</span><br><span class=\"line\">    response.set_headers(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"Flask-钩子函数\"><a href=\"#Flask-钩子函数\" class=\"headerlink\" title=\"Flask 钩子函数:\"></a>Flask 钩子函数:</h4><p>在客户端和服务端网络交互的过程中, 有时需要对交互过程, 或者在交互前后,做一定的处理. 这个时候框架提供的接口就很重要了,<br>一般我们可能称这些接口为中间件或者事件钩子. 就是像是你在学校想叫个外卖, 然后你又不能出去. 这个时候你就找个钩子放到墙外, 告诉老板, 把东西放在钩子上.<br>哪么Flask 也为我们提供了一些钩子函数</p>\n<ol>\n<li><p>before_first_request<br> 在第一次请求时触发</p>\n</li>\n<li><p>after_request<br> 在请求正常处理之后触发</p>\n</li>\n<li><p>before_request<br> 在请求进入视图函数处理之前触发</p>\n</li>\n<li><p>teardown_request<br> 在每次请求之后触发, 处理异常响应</p>\n</li>\n</ol>\n<p>使用方式也很简单, 就是装饰器一样</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@app.before_request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handler_request</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>注意 after_request 和 teardown_request 装饰的函数, 需要定义一个参数用来接收响应, 不然会出现问题.</p>\n<p>说完了Flask 提供给的钩子, 哪么我们具体来说一下它们的实际应用场景</p>\n<p>before_request 在请求进入视图函数之前做处理, 哪么我们想想, 哪些是需要在处理请求之前要做的事情.</p>\n<ul>\n<li>验证用户信息</li>\n<li>验证用户权限</li>\n<li>验证请求参数</li>\n<li>对请求头进行验证, 尤其是跨域中, 我们需要对指定的请求头做处理.</li>\n<li>甚至为用户request 的添加属性, 或者绑定方法</li>\n</ul>\n<p>而这些操作都需要或者间接需要对request 做处理哪么, 在使用时, 需要导入request</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, request, make_response</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">allowed_host = [<span class=\"string\">&#x27;www.host.com&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.before_request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handler_cors_request</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        处理跨域问题</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    origin = request.headers[<span class=\"string\">&#x27;origin&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> origin <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> allowed_host:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> make_response()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.after_request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handler_cors_response</span>(<span class=\"params\">response</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        cors 最主要的是在返回响应时, 服务端告诉前端, 是否允许跨域, cookie能不能, headers 能不能跨域</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    response.set_headers(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, request.full_path)</span><br><span class=\"line\">    response.set_headers(<span class=\"string\">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class=\"literal\">True</span>)</span><br><span class=\"line\">    response.set_headers(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n"},{"title":"Mysql 事务级别","date":"2017-10-20T15:18:36.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Mysql 事务级别\n\n* 串行 serializer\n* ","source":"_posts/Mysql-事务级别.md","raw":"---\ntitle: Mysql 事务级别\ndate: 2017-10-20 23:18:36\ntags: Mysql\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Mysql 事务级别\n\n* 串行 serializer\n* ","slug":"Mysql-事务级别","published":1,"updated":"2020-11-03T14:07:06.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdx000ko8t29srx6g12","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Mysql-事务级别\"><a href=\"#Mysql-事务级别\" class=\"headerlink\" title=\"Mysql 事务级别\"></a>Mysql 事务级别</h3><ul>\n<li>串行 serializer</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Mysql-事务级别\"><a href=\"#Mysql-事务级别\" class=\"headerlink\" title=\"Mysql 事务级别\"></a>Mysql 事务级别</h3><ul>\n<li>串行 serializer</li>\n<li></li>\n</ul>\n"},{"title":"django中理解mixins","date":"2017-10-22T05:45:01.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Django Rest framework 体现的Mixin 模式\n\n刚开始接触 rest framework 时, 有点难以理解. 甚至并没有掌握到这个框架的好处(最大的好处在于,快速撸完接口下班), 甚至因为性能问题没有对这个框架有一个全面的认识.\n不过当你之掌握了, python世界的规律了之后你会发现真香. \n\nRf 主要提供了视图扩展和数据序列化和反序列化, 两者共同合作撸一个api 简直不要太爽.\n\n先说视图:\n* APIView 继承之 django.View 并重写 as_view 方法\n    \n* GenericAPIView 继承之APIView 并扩展结合序列化类和查询集的通用操作\n通过上面两者实现的功能, 你就会发现.APIView 简单扩展了原生View, 对于serializer的结合并不是特别深入.\n而GenericAPIView 通过封装了, 多个通用的操作:\n\n* get_queryset(self)\n    1. 获取查询集\n    \n* get_object(self)\n    1. 获取过滤后的查询集\n    2. 通过设置的查询字段从查询集中通过字段获取model\n    3. 检查是否有权限获取当前对象\n    \n* get_serializer(self)\n    1. 获取声明时定义的class\n    2. 构造serializer 相关的context\n    3. 通过参数实例化serializer_class\n    \n* get_serializer_context(self)\n    1. return 声明时定义的serializer_class\n    \n* filter_queryset(self)\n    1. 根据定义的过滤后端过滤queryset\n    \n* paginate_queryset\n    1. 根据定义的paginate_class 对queryset分页\n    \n在整个rest framework api 周期内部, 都是围绕serializer 来工作的. 因为它是model 的上层.\n应该说是数据源的上层, 官方给serializer 的定位是模型和非模型数据处理. \n\n哪么现在我动手撸一个创建用户的api\n\n现在我希望用户register的时候, 带上一些我需要的信息,\n\n```python\nclass RegisterView(View):\n    \n    def post(self, request, *args, **kwargs):\n        # get data\n        # check data\n        # create user model\n        # return response\n        return HttpResponse()\n```\n这是一个正常的Djanog 视图, 现在我扩展一下使用rest\n\nserializer.py\n```python\nfrom rest_framework import serializers\nfrom .models import User \nclass UserSerializer(serializers.ModelSerialzier):\n    password = serializers.CharField(max_length=1024, write_only=True)      # 声明此字段只用做反序列化\n    \n    class Meta:\n        model= User\n        fields = '__all__'\n\n```\n\nviews.py\n```python\nfrom rest_framework import generics\nfrom .serializers import UserSerializer\nfrom .models import User\n\n\nclass RegisterFulView(generics.CreateAPIView,\n                        generics.RetrieveAPIView):\n    \n    lookup_url_kwarg = 'id' # 注意通过api参数传递的参数名称\n    serializer_class = UserSerializer\n    queryset = User.objects.all()    \n\n    \n```\n\nurls.py\n```python\n\n# 二级 url\npath('/create/', RegisterFulView.as_view())\npath('/<int:id>/', RegisterFulView.as_view())   # api参数要和视图中定义的一致\n\n```\n\n最后在urls 中注册路由, 然后你就完成了这个用户注册的接口. 什么这就完成了, 并且我们还完成了用户的信息获取\n是不是不可思议, 的确有点扯. 但就是完成了, 借助python的动态特性和mixin模式, 完成了api.\n注意我们的参数效验rest在底层帮我们做了, 但是验证规则没有, 所以我们还需要定义验证规则. 这个内容在rest framework 中有提到\n##### 总结:\n结合rest 实现api时\n1. 找一个符合当前业务的GenericAPIView\n2. 定义好serializer 和model\n3. 定义好指定字段的验证逻辑\n4. 注册你的api","source":"_posts/django中理解mixins.md","raw":"---\ntitle: django中理解mixins\ndate: 2017-10-22 13:45:01\ntags: Django, 设计模式\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Django Rest framework 体现的Mixin 模式\n\n刚开始接触 rest framework 时, 有点难以理解. 甚至并没有掌握到这个框架的好处(最大的好处在于,快速撸完接口下班), 甚至因为性能问题没有对这个框架有一个全面的认识.\n不过当你之掌握了, python世界的规律了之后你会发现真香. \n\nRf 主要提供了视图扩展和数据序列化和反序列化, 两者共同合作撸一个api 简直不要太爽.\n\n先说视图:\n* APIView 继承之 django.View 并重写 as_view 方法\n    \n* GenericAPIView 继承之APIView 并扩展结合序列化类和查询集的通用操作\n通过上面两者实现的功能, 你就会发现.APIView 简单扩展了原生View, 对于serializer的结合并不是特别深入.\n而GenericAPIView 通过封装了, 多个通用的操作:\n\n* get_queryset(self)\n    1. 获取查询集\n    \n* get_object(self)\n    1. 获取过滤后的查询集\n    2. 通过设置的查询字段从查询集中通过字段获取model\n    3. 检查是否有权限获取当前对象\n    \n* get_serializer(self)\n    1. 获取声明时定义的class\n    2. 构造serializer 相关的context\n    3. 通过参数实例化serializer_class\n    \n* get_serializer_context(self)\n    1. return 声明时定义的serializer_class\n    \n* filter_queryset(self)\n    1. 根据定义的过滤后端过滤queryset\n    \n* paginate_queryset\n    1. 根据定义的paginate_class 对queryset分页\n    \n在整个rest framework api 周期内部, 都是围绕serializer 来工作的. 因为它是model 的上层.\n应该说是数据源的上层, 官方给serializer 的定位是模型和非模型数据处理. \n\n哪么现在我动手撸一个创建用户的api\n\n现在我希望用户register的时候, 带上一些我需要的信息,\n\n```python\nclass RegisterView(View):\n    \n    def post(self, request, *args, **kwargs):\n        # get data\n        # check data\n        # create user model\n        # return response\n        return HttpResponse()\n```\n这是一个正常的Djanog 视图, 现在我扩展一下使用rest\n\nserializer.py\n```python\nfrom rest_framework import serializers\nfrom .models import User \nclass UserSerializer(serializers.ModelSerialzier):\n    password = serializers.CharField(max_length=1024, write_only=True)      # 声明此字段只用做反序列化\n    \n    class Meta:\n        model= User\n        fields = '__all__'\n\n```\n\nviews.py\n```python\nfrom rest_framework import generics\nfrom .serializers import UserSerializer\nfrom .models import User\n\n\nclass RegisterFulView(generics.CreateAPIView,\n                        generics.RetrieveAPIView):\n    \n    lookup_url_kwarg = 'id' # 注意通过api参数传递的参数名称\n    serializer_class = UserSerializer\n    queryset = User.objects.all()    \n\n    \n```\n\nurls.py\n```python\n\n# 二级 url\npath('/create/', RegisterFulView.as_view())\npath('/<int:id>/', RegisterFulView.as_view())   # api参数要和视图中定义的一致\n\n```\n\n最后在urls 中注册路由, 然后你就完成了这个用户注册的接口. 什么这就完成了, 并且我们还完成了用户的信息获取\n是不是不可思议, 的确有点扯. 但就是完成了, 借助python的动态特性和mixin模式, 完成了api.\n注意我们的参数效验rest在底层帮我们做了, 但是验证规则没有, 所以我们还需要定义验证规则. 这个内容在rest framework 中有提到\n##### 总结:\n结合rest 实现api时\n1. 找一个符合当前业务的GenericAPIView\n2. 定义好serializer 和model\n3. 定义好指定字段的验证逻辑\n4. 注册你的api","slug":"django中理解mixins","published":1,"updated":"2020-11-03T14:07:06.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdy000lo8t20t7n6qlz","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Django-Rest-framework-体现的Mixin-模式\"><a href=\"#Django-Rest-framework-体现的Mixin-模式\" class=\"headerlink\" title=\"Django Rest framework 体现的Mixin 模式\"></a>Django Rest framework 体现的Mixin 模式</h3><p>刚开始接触 rest framework 时, 有点难以理解. 甚至并没有掌握到这个框架的好处(最大的好处在于,快速撸完接口下班), 甚至因为性能问题没有对这个框架有一个全面的认识.<br>不过当你之掌握了, python世界的规律了之后你会发现真香. </p>\n<p>Rf 主要提供了视图扩展和数据序列化和反序列化, 两者共同合作撸一个api 简直不要太爽.</p>\n<p>先说视图:</p>\n<ul>\n<li><p>APIView 继承之 django.View 并重写 as_view 方法</p>\n</li>\n<li><p>GenericAPIView 继承之APIView 并扩展结合序列化类和查询集的通用操作<br>通过上面两者实现的功能, 你就会发现.APIView 简单扩展了原生View, 对于serializer的结合并不是特别深入.<br>而GenericAPIView 通过封装了, 多个通用的操作:</p>\n</li>\n<li><p>get_queryset(self)</p>\n<ol>\n<li>获取查询集</li>\n</ol>\n</li>\n<li><p>get_object(self)</p>\n<ol>\n<li>获取过滤后的查询集</li>\n<li>通过设置的查询字段从查询集中通过字段获取model</li>\n<li>检查是否有权限获取当前对象</li>\n</ol>\n</li>\n<li><p>get_serializer(self)</p>\n<ol>\n<li>获取声明时定义的class</li>\n<li>构造serializer 相关的context</li>\n<li>通过参数实例化serializer_class</li>\n</ol>\n</li>\n<li><p>get_serializer_context(self)</p>\n<ol>\n<li>return 声明时定义的serializer_class</li>\n</ol>\n</li>\n<li><p>filter_queryset(self)</p>\n<ol>\n<li>根据定义的过滤后端过滤queryset</li>\n</ol>\n</li>\n<li><p>paginate_queryset</p>\n<ol>\n<li>根据定义的paginate_class 对queryset分页</li>\n</ol>\n</li>\n</ul>\n<p>在整个rest framework api 周期内部, 都是围绕serializer 来工作的. 因为它是model 的上层.<br>应该说是数据源的上层, 官方给serializer 的定位是模型和非模型数据处理. </p>\n<p>哪么现在我动手撸一个创建用户的api</p>\n<p>现在我希望用户register的时候, 带上一些我需要的信息,</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegisterView</span>(<span class=\"params\">View</span>):</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span>(<span class=\"params\">self, request, *args, **kwargs</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># get data</span></span><br><span class=\"line\">        <span class=\"comment\"># check data</span></span><br><span class=\"line\">        <span class=\"comment\"># create user model</span></span><br><span class=\"line\">        <span class=\"comment\"># return response</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse()</span><br></pre></td></tr></table></figure>\n<p>这是一个正常的Djanog 视图, 现在我扩展一下使用rest</p>\n<p>serializer.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> serializers</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> User </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserSerializer</span>(<span class=\"params\">serializers.ModelSerialzier</span>):</span></span><br><span class=\"line\">    password = serializers.CharField(max_length=<span class=\"number\">1024</span>, write_only=<span class=\"literal\">True</span>)      <span class=\"comment\"># 声明此字段只用做反序列化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        model= User</span><br><span class=\"line\">        fields = <span class=\"string\">&#x27;__all__&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>views.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> generics</span><br><span class=\"line\"><span class=\"keyword\">from</span> .serializers <span class=\"keyword\">import</span> UserSerializer</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> User</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegisterFulView</span>(<span class=\"params\">generics.CreateAPIView,</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"params\">                        generics.RetrieveAPIView</span>):</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    lookup_url_kwarg = <span class=\"string\">&#x27;id&#x27;</span> <span class=\"comment\"># 注意通过api参数传递的参数名称</span></span><br><span class=\"line\">    serializer_class = UserSerializer</span><br><span class=\"line\">    queryset = User.objects.all()    </span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>urls.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 二级 url</span></span><br><span class=\"line\">path(<span class=\"string\">&#x27;/create/&#x27;</span>, RegisterFulView.as_view())</span><br><span class=\"line\">path(<span class=\"string\">&#x27;/&lt;int:id&gt;/&#x27;</span>, RegisterFulView.as_view())   <span class=\"comment\"># api参数要和视图中定义的一致</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>最后在urls 中注册路由, 然后你就完成了这个用户注册的接口. 什么这就完成了, 并且我们还完成了用户的信息获取<br>是不是不可思议, 的确有点扯. 但就是完成了, 借助python的动态特性和mixin模式, 完成了api.<br>注意我们的参数效验rest在底层帮我们做了, 但是验证规则没有, 所以我们还需要定义验证规则. 这个内容在rest framework 中有提到</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h5><p>结合rest 实现api时</p>\n<ol>\n<li>找一个符合当前业务的GenericAPIView</li>\n<li>定义好serializer 和model</li>\n<li>定义好指定字段的验证逻辑</li>\n<li>注册你的api</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Django-Rest-framework-体现的Mixin-模式\"><a href=\"#Django-Rest-framework-体现的Mixin-模式\" class=\"headerlink\" title=\"Django Rest framework 体现的Mixin 模式\"></a>Django Rest framework 体现的Mixin 模式</h3><p>刚开始接触 rest framework 时, 有点难以理解. 甚至并没有掌握到这个框架的好处(最大的好处在于,快速撸完接口下班), 甚至因为性能问题没有对这个框架有一个全面的认识.<br>不过当你之掌握了, python世界的规律了之后你会发现真香. </p>\n<p>Rf 主要提供了视图扩展和数据序列化和反序列化, 两者共同合作撸一个api 简直不要太爽.</p>\n<p>先说视图:</p>\n<ul>\n<li><p>APIView 继承之 django.View 并重写 as_view 方法</p>\n</li>\n<li><p>GenericAPIView 继承之APIView 并扩展结合序列化类和查询集的通用操作<br>通过上面两者实现的功能, 你就会发现.APIView 简单扩展了原生View, 对于serializer的结合并不是特别深入.<br>而GenericAPIView 通过封装了, 多个通用的操作:</p>\n</li>\n<li><p>get_queryset(self)</p>\n<ol>\n<li>获取查询集</li>\n</ol>\n</li>\n<li><p>get_object(self)</p>\n<ol>\n<li>获取过滤后的查询集</li>\n<li>通过设置的查询字段从查询集中通过字段获取model</li>\n<li>检查是否有权限获取当前对象</li>\n</ol>\n</li>\n<li><p>get_serializer(self)</p>\n<ol>\n<li>获取声明时定义的class</li>\n<li>构造serializer 相关的context</li>\n<li>通过参数实例化serializer_class</li>\n</ol>\n</li>\n<li><p>get_serializer_context(self)</p>\n<ol>\n<li>return 声明时定义的serializer_class</li>\n</ol>\n</li>\n<li><p>filter_queryset(self)</p>\n<ol>\n<li>根据定义的过滤后端过滤queryset</li>\n</ol>\n</li>\n<li><p>paginate_queryset</p>\n<ol>\n<li>根据定义的paginate_class 对queryset分页</li>\n</ol>\n</li>\n</ul>\n<p>在整个rest framework api 周期内部, 都是围绕serializer 来工作的. 因为它是model 的上层.<br>应该说是数据源的上层, 官方给serializer 的定位是模型和非模型数据处理. </p>\n<p>哪么现在我动手撸一个创建用户的api</p>\n<p>现在我希望用户register的时候, 带上一些我需要的信息,</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegisterView</span>(<span class=\"params\">View</span>):</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span>(<span class=\"params\">self, request, *args, **kwargs</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># get data</span></span><br><span class=\"line\">        <span class=\"comment\"># check data</span></span><br><span class=\"line\">        <span class=\"comment\"># create user model</span></span><br><span class=\"line\">        <span class=\"comment\"># return response</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse()</span><br></pre></td></tr></table></figure>\n<p>这是一个正常的Djanog 视图, 现在我扩展一下使用rest</p>\n<p>serializer.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> serializers</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> User </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserSerializer</span>(<span class=\"params\">serializers.ModelSerialzier</span>):</span></span><br><span class=\"line\">    password = serializers.CharField(max_length=<span class=\"number\">1024</span>, write_only=<span class=\"literal\">True</span>)      <span class=\"comment\"># 声明此字段只用做反序列化</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        model= User</span><br><span class=\"line\">        fields = <span class=\"string\">&#x27;__all__&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>views.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> generics</span><br><span class=\"line\"><span class=\"keyword\">from</span> .serializers <span class=\"keyword\">import</span> UserSerializer</span><br><span class=\"line\"><span class=\"keyword\">from</span> .models <span class=\"keyword\">import</span> User</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegisterFulView</span>(<span class=\"params\">generics.CreateAPIView,</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"params\">                        generics.RetrieveAPIView</span>):</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    lookup_url_kwarg = <span class=\"string\">&#x27;id&#x27;</span> <span class=\"comment\"># 注意通过api参数传递的参数名称</span></span><br><span class=\"line\">    serializer_class = UserSerializer</span><br><span class=\"line\">    queryset = User.objects.all()    </span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>urls.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 二级 url</span></span><br><span class=\"line\">path(<span class=\"string\">&#x27;/create/&#x27;</span>, RegisterFulView.as_view())</span><br><span class=\"line\">path(<span class=\"string\">&#x27;/&lt;int:id&gt;/&#x27;</span>, RegisterFulView.as_view())   <span class=\"comment\"># api参数要和视图中定义的一致</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>最后在urls 中注册路由, 然后你就完成了这个用户注册的接口. 什么这就完成了, 并且我们还完成了用户的信息获取<br>是不是不可思议, 的确有点扯. 但就是完成了, 借助python的动态特性和mixin模式, 完成了api.<br>注意我们的参数效验rest在底层帮我们做了, 但是验证规则没有, 所以我们还需要定义验证规则. 这个内容在rest framework 中有提到</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h5><p>结合rest 实现api时</p>\n<ol>\n<li>找一个符合当前业务的GenericAPIView</li>\n<li>定义好serializer 和model</li>\n<li>定义好指定字段的验证逻辑</li>\n<li>注册你的api</li>\n</ol>\n"},{"title":"Eventlet与flask-sqlalchemy的结合","date":"2018-11-03T06:36:19.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n###  Eventlet与 flask-sqlalchemy的结合\n在python中, 常因为性能原因苦恼, 偶然之间发现了eventlet 这个神器, 用来在单线程中模拟协程操作搭配多个gunicorn进程实现并发的手段.\neventlet 基于epoll IO模型实现非阻塞io, 并封装了greenlet实现协程调度. 但由于python解释器的一些限制. 在一些orm中不能直接使用.\n通过翻看文档和借鉴 openstack的处理方式.\n\n```python\nfrom flask import Flask\nfrom sqlalchemy import pool\nfrom flask_sqlalchemy import Sqlaclhemy\nimport eventlet.pool\nimport MySQLdb\n\napp = Flask(__name__)\n\n\n# 方式一\n# 此方法来源于openstack nova 注意使用MySQLldb\nurl_args = {}\napp.config['SQLALCHEMY_ENGINE_OPTIONS'] = {'creater': eventlet.pool.ConnectionPool(MySQLdb, **url_args).create}\ndb = Sqlaclhemy(app)\n\n# 方式二\neventlet.monkey_patch(thread=True)\n# 由于flask中封装了 scoped_session 所以我们可以在patch后直接使用session, 它是协程安全的\n\n```","source":"_posts/eventlet与flask-sqlalchemy的结合.md","raw":"---\ntitle: Eventlet与flask-sqlalchemy的结合\ndate: 2018-11-03 14:36:19\ntags: Eventlet, Flask, Sqlalchemy\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n###  Eventlet与 flask-sqlalchemy的结合\n在python中, 常因为性能原因苦恼, 偶然之间发现了eventlet 这个神器, 用来在单线程中模拟协程操作搭配多个gunicorn进程实现并发的手段.\neventlet 基于epoll IO模型实现非阻塞io, 并封装了greenlet实现协程调度. 但由于python解释器的一些限制. 在一些orm中不能直接使用.\n通过翻看文档和借鉴 openstack的处理方式.\n\n```python\nfrom flask import Flask\nfrom sqlalchemy import pool\nfrom flask_sqlalchemy import Sqlaclhemy\nimport eventlet.pool\nimport MySQLdb\n\napp = Flask(__name__)\n\n\n# 方式一\n# 此方法来源于openstack nova 注意使用MySQLldb\nurl_args = {}\napp.config['SQLALCHEMY_ENGINE_OPTIONS'] = {'creater': eventlet.pool.ConnectionPool(MySQLdb, **url_args).create}\ndb = Sqlaclhemy(app)\n\n# 方式二\neventlet.monkey_patch(thread=True)\n# 由于flask中封装了 scoped_session 所以我们可以在patch后直接使用session, 它是协程安全的\n\n```","slug":"eventlet与flask-sqlalchemy的结合","published":1,"updated":"2020-11-03T14:07:06.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjdz000no8t2hwiq0kl0","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Eventlet与-flask-sqlalchemy的结合\"><a href=\"#Eventlet与-flask-sqlalchemy的结合\" class=\"headerlink\" title=\"Eventlet与 flask-sqlalchemy的结合\"></a>Eventlet与 flask-sqlalchemy的结合</h3><p>在python中, 常因为性能原因苦恼, 偶然之间发现了eventlet 这个神器, 用来在单线程中模拟协程操作搭配多个gunicorn进程实现并发的手段.<br>eventlet 基于epoll IO模型实现非阻塞io, 并封装了greenlet实现协程调度. 但由于python解释器的一些限制. 在一些orm中不能直接使用.<br>通过翻看文档和借鉴 openstack的处理方式.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy <span class=\"keyword\">import</span> pool</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> Sqlaclhemy</span><br><span class=\"line\"><span class=\"keyword\">import</span> eventlet.pool</span><br><span class=\"line\"><span class=\"keyword\">import</span> MySQLdb</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式一</span></span><br><span class=\"line\"><span class=\"comment\"># 此方法来源于openstack nova 注意使用MySQLldb</span></span><br><span class=\"line\">url_args = &#123;&#125;</span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_ENGINE_OPTIONS&#x27;</span>] = &#123;<span class=\"string\">&#x27;creater&#x27;</span>: eventlet.pool.ConnectionPool(MySQLdb, **url_args).create&#125;</span><br><span class=\"line\">db = Sqlaclhemy(app)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式二</span></span><br><span class=\"line\">eventlet.monkey_patch(thread=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 由于flask中封装了 scoped_session 所以我们可以在patch后直接使用session, 它是协程安全的</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Eventlet与-flask-sqlalchemy的结合\"><a href=\"#Eventlet与-flask-sqlalchemy的结合\" class=\"headerlink\" title=\"Eventlet与 flask-sqlalchemy的结合\"></a>Eventlet与 flask-sqlalchemy的结合</h3><p>在python中, 常因为性能原因苦恼, 偶然之间发现了eventlet 这个神器, 用来在单线程中模拟协程操作搭配多个gunicorn进程实现并发的手段.<br>eventlet 基于epoll IO模型实现非阻塞io, 并封装了greenlet实现协程调度. 但由于python解释器的一些限制. 在一些orm中不能直接使用.<br>通过翻看文档和借鉴 openstack的处理方式.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> sqlalchemy <span class=\"keyword\">import</span> pool</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_sqlalchemy <span class=\"keyword\">import</span> Sqlaclhemy</span><br><span class=\"line\"><span class=\"keyword\">import</span> eventlet.pool</span><br><span class=\"line\"><span class=\"keyword\">import</span> MySQLdb</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式一</span></span><br><span class=\"line\"><span class=\"comment\"># 此方法来源于openstack nova 注意使用MySQLldb</span></span><br><span class=\"line\">url_args = &#123;&#125;</span><br><span class=\"line\">app.config[<span class=\"string\">&#x27;SQLALCHEMY_ENGINE_OPTIONS&#x27;</span>] = &#123;<span class=\"string\">&#x27;creater&#x27;</span>: eventlet.pool.ConnectionPool(MySQLdb, **url_args).create&#125;</span><br><span class=\"line\">db = Sqlaclhemy(app)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式二</span></span><br><span class=\"line\">eventlet.monkey_patch(thread=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"comment\"># 由于flask中封装了 scoped_session 所以我们可以在patch后直接使用session, 它是协程安全的</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"flask-sqlalchemy-复杂查询","date":"2017-10-11T08:41:48.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask Sqlalchemy 构造复杂查询\n\n在日常的开发中难免会使用sqlalchemy 写一些复杂的sql语句。 而在sqlalchemy中查询的方法大体分为两种。\n1. 使用模型类查询\n2. 使用db.session 查询\n两种方式都需要根据业务来做选择， 比如我只需要根据id查模型肯定第一种方式比较效率一点。 但在orm中需要认识到几个概念\n* 查询器\n    sqlalchemy 原生提供的查询器:\n        * first 获取数据集的第一条数据\n        * get   通过id 获取数据\n        * all   获取所有数据\n        \n* 过滤器\n        * filter_by 只支持字段参数\n        * filter   只支持sql表达式\n两者最大的区别在于第二种支持丰富的sql构造\nfilter 处理复杂的语句\n```python\n# 条件查询\nModel.query.filter(Model.field == 'value').first()      # 注意查询需要通过查询器触发\n# and 查询\nModel.query.filter(MOdel.field == 'value', Model.field1 == 'value1').first()\n# or 查询\nModel.query.filter(or_(Model.field=='value', Model.name.endswith('value1'))).all()\n# not 查询\nModel.query.filter(not_(Model.field=='value')).first()\n# limit 使用\nModel.query.limit(3).all()  # 获取所有数据的前三条数据\n# offset 使用\nModel.query.limit(3).offset(2).all() #获取所有数据中 从第二条数据开始的三条数据\n# order 使用\nModel.query.order_by(Model.id.desc()).all() # 对所有数据以id降序排列\nModel.query.order_by(Model.id.asc()).all() # 对所有数据以id升序排列\n\n# 模糊查询\nModel.query(Model).filter(\n#     # Model.field.startswith('eds'),  \n#     # Model.field.endswith('1e'),     \n#     # Model.field.contains('l')\n     Model.field.like(\"__d%\")\n).all()\n```\n","source":"_posts/flask-sqlalchemy-复杂查询.md","raw":"---\ntitle: flask-sqlalchemy-复杂查询\ndate: 2017-10-11 16:41:48\ntags: Flask, Sqlalchemy\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask Sqlalchemy 构造复杂查询\n\n在日常的开发中难免会使用sqlalchemy 写一些复杂的sql语句。 而在sqlalchemy中查询的方法大体分为两种。\n1. 使用模型类查询\n2. 使用db.session 查询\n两种方式都需要根据业务来做选择， 比如我只需要根据id查模型肯定第一种方式比较效率一点。 但在orm中需要认识到几个概念\n* 查询器\n    sqlalchemy 原生提供的查询器:\n        * first 获取数据集的第一条数据\n        * get   通过id 获取数据\n        * all   获取所有数据\n        \n* 过滤器\n        * filter_by 只支持字段参数\n        * filter   只支持sql表达式\n两者最大的区别在于第二种支持丰富的sql构造\nfilter 处理复杂的语句\n```python\n# 条件查询\nModel.query.filter(Model.field == 'value').first()      # 注意查询需要通过查询器触发\n# and 查询\nModel.query.filter(MOdel.field == 'value', Model.field1 == 'value1').first()\n# or 查询\nModel.query.filter(or_(Model.field=='value', Model.name.endswith('value1'))).all()\n# not 查询\nModel.query.filter(not_(Model.field=='value')).first()\n# limit 使用\nModel.query.limit(3).all()  # 获取所有数据的前三条数据\n# offset 使用\nModel.query.limit(3).offset(2).all() #获取所有数据中 从第二条数据开始的三条数据\n# order 使用\nModel.query.order_by(Model.id.desc()).all() # 对所有数据以id降序排列\nModel.query.order_by(Model.id.asc()).all() # 对所有数据以id升序排列\n\n# 模糊查询\nModel.query(Model).filter(\n#     # Model.field.startswith('eds'),  \n#     # Model.field.endswith('1e'),     \n#     # Model.field.contains('l')\n     Model.field.like(\"__d%\")\n).all()\n```\n","slug":"flask-sqlalchemy-复杂查询","published":1,"updated":"2020-11-05T11:23:56.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje0000po8t2fm20gzki","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-Sqlalchemy-构造复杂查询\"><a href=\"#Flask-Sqlalchemy-构造复杂查询\" class=\"headerlink\" title=\"Flask Sqlalchemy 构造复杂查询\"></a>Flask Sqlalchemy 构造复杂查询</h2><p>在日常的开发中难免会使用sqlalchemy 写一些复杂的sql语句。 而在sqlalchemy中查询的方法大体分为两种。</p>\n<ol>\n<li>使用模型类查询</li>\n<li>使用db.session 查询<br>两种方式都需要根据业务来做选择， 比如我只需要根据id查模型肯定第一种方式比较效率一点。 但在orm中需要认识到几个概念</li>\n</ol>\n<ul>\n<li><p>查询器<br>  sqlalchemy 原生提供的查询器:</p>\n<pre><code>  * first 获取数据集的第一条数据\n  * get   通过id 获取数据\n  * all   获取所有数据</code></pre>\n</li>\n<li><p>过滤器</p>\n<pre><code>  * filter_by 只支持字段参数\n  * filter   只支持sql表达式</code></pre>\n<p>两者最大的区别在于第二种支持丰富的sql构造<br>filter 处理复杂的语句</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 条件查询</span></span><br><span class=\"line\">Model.query.filter(Model.field == <span class=\"string\">&#x27;value&#x27;</span>).first()      <span class=\"comment\"># 注意查询需要通过查询器触发</span></span><br><span class=\"line\"><span class=\"comment\"># and 查询</span></span><br><span class=\"line\">Model.query.filter(MOdel.field == <span class=\"string\">&#x27;value&#x27;</span>, Model.field1 == <span class=\"string\">&#x27;value1&#x27;</span>).first()</span><br><span class=\"line\"><span class=\"comment\"># or 查询</span></span><br><span class=\"line\">Model.query.filter(or_(Model.field==<span class=\"string\">&#x27;value&#x27;</span>, Model.name.endswith(<span class=\"string\">&#x27;value1&#x27;</span>))).all()</span><br><span class=\"line\"><span class=\"comment\"># not 查询</span></span><br><span class=\"line\">Model.query.filter(not_(Model.field==<span class=\"string\">&#x27;value&#x27;</span>)).first()</span><br><span class=\"line\"><span class=\"comment\"># limit 使用</span></span><br><span class=\"line\">Model.query.limit(<span class=\"number\">3</span>).all()  <span class=\"comment\"># 获取所有数据的前三条数据</span></span><br><span class=\"line\"><span class=\"comment\"># offset 使用</span></span><br><span class=\"line\">Model.query.limit(<span class=\"number\">3</span>).offset(<span class=\"number\">2</span>).all() <span class=\"comment\">#获取所有数据中 从第二条数据开始的三条数据</span></span><br><span class=\"line\"><span class=\"comment\"># order 使用</span></span><br><span class=\"line\">Model.query.order_by(Model.id.desc()).all() <span class=\"comment\"># 对所有数据以id降序排列</span></span><br><span class=\"line\">Model.query.order_by(Model.id.asc()).all() <span class=\"comment\"># 对所有数据以id升序排列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模糊查询</span></span><br><span class=\"line\">Model.query(Model).filter(</span><br><span class=\"line\"><span class=\"comment\">#     # Model.field.startswith(&#x27;eds&#x27;),  </span></span><br><span class=\"line\"><span class=\"comment\">#     # Model.field.endswith(&#x27;1e&#x27;),     </span></span><br><span class=\"line\"><span class=\"comment\">#     # Model.field.contains(&#x27;l&#x27;)</span></span><br><span class=\"line\">     Model.field.like(<span class=\"string\">&quot;__d%&quot;</span>)</span><br><span class=\"line\">).all()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-Sqlalchemy-构造复杂查询\"><a href=\"#Flask-Sqlalchemy-构造复杂查询\" class=\"headerlink\" title=\"Flask Sqlalchemy 构造复杂查询\"></a>Flask Sqlalchemy 构造复杂查询</h2><p>在日常的开发中难免会使用sqlalchemy 写一些复杂的sql语句。 而在sqlalchemy中查询的方法大体分为两种。</p>\n<ol>\n<li>使用模型类查询</li>\n<li>使用db.session 查询<br>两种方式都需要根据业务来做选择， 比如我只需要根据id查模型肯定第一种方式比较效率一点。 但在orm中需要认识到几个概念</li>\n</ol>\n<ul>\n<li><p>查询器<br>  sqlalchemy 原生提供的查询器:</p>\n<pre><code>  * first 获取数据集的第一条数据\n  * get   通过id 获取数据\n  * all   获取所有数据</code></pre>\n</li>\n<li><p>过滤器</p>\n<pre><code>  * filter_by 只支持字段参数\n  * filter   只支持sql表达式</code></pre>\n<p>两者最大的区别在于第二种支持丰富的sql构造<br>filter 处理复杂的语句</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 条件查询</span></span><br><span class=\"line\">Model.query.filter(Model.field == <span class=\"string\">&#x27;value&#x27;</span>).first()      <span class=\"comment\"># 注意查询需要通过查询器触发</span></span><br><span class=\"line\"><span class=\"comment\"># and 查询</span></span><br><span class=\"line\">Model.query.filter(MOdel.field == <span class=\"string\">&#x27;value&#x27;</span>, Model.field1 == <span class=\"string\">&#x27;value1&#x27;</span>).first()</span><br><span class=\"line\"><span class=\"comment\"># or 查询</span></span><br><span class=\"line\">Model.query.filter(or_(Model.field==<span class=\"string\">&#x27;value&#x27;</span>, Model.name.endswith(<span class=\"string\">&#x27;value1&#x27;</span>))).all()</span><br><span class=\"line\"><span class=\"comment\"># not 查询</span></span><br><span class=\"line\">Model.query.filter(not_(Model.field==<span class=\"string\">&#x27;value&#x27;</span>)).first()</span><br><span class=\"line\"><span class=\"comment\"># limit 使用</span></span><br><span class=\"line\">Model.query.limit(<span class=\"number\">3</span>).all()  <span class=\"comment\"># 获取所有数据的前三条数据</span></span><br><span class=\"line\"><span class=\"comment\"># offset 使用</span></span><br><span class=\"line\">Model.query.limit(<span class=\"number\">3</span>).offset(<span class=\"number\">2</span>).all() <span class=\"comment\">#获取所有数据中 从第二条数据开始的三条数据</span></span><br><span class=\"line\"><span class=\"comment\"># order 使用</span></span><br><span class=\"line\">Model.query.order_by(Model.id.desc()).all() <span class=\"comment\"># 对所有数据以id降序排列</span></span><br><span class=\"line\">Model.query.order_by(Model.id.asc()).all() <span class=\"comment\"># 对所有数据以id升序排列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模糊查询</span></span><br><span class=\"line\">Model.query(Model).filter(</span><br><span class=\"line\"><span class=\"comment\">#     # Model.field.startswith(&#x27;eds&#x27;),  </span></span><br><span class=\"line\"><span class=\"comment\">#     # Model.field.endswith(&#x27;1e&#x27;),     </span></span><br><span class=\"line\"><span class=\"comment\">#     # Model.field.contains(&#x27;l&#x27;)</span></span><br><span class=\"line\">     Model.field.like(<span class=\"string\">&quot;__d%&quot;</span>)</span><br><span class=\"line\">).all()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"Flask 路由和蓝图","date":"2017-10-10T08:45:50.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Flask - Route - Blueprint\n\n在 flask 中创建路由是一件简单事情\n```python\nfrom flask import Flask, url_for\n\n\n# app 本质也可以看成一个蓝图\napp = Flask(__name__)\n\n# 定义路由\n@app.route('/', methods=['GET'])\ndef index():\n    return \"flask world\"\n\n# 方式二\napp.add_url_rule('/', 'index', index)   # 注意这种方式的endpoint 需要自己手动提供\n\n# route 内部做几件事情\n# 1. 根据参数, 决定这个函数的url路径, 并将这个url添加到 当前蓝图的url_map中\n# 2. 同时创建一个endpoint, 如果参数没有传递, 就将函数名作为endpoint, 好处就是当endpoint 作为函数id时, 在使用反向生成url会特别轻松\n# 3. url访问的流程就是 url -> app -> endpoint -> view_func\n\nurl = url_for('.index')     # 当前蓝图下面的index函数的url\n\n```\n\n而flask 中的蓝图使用\n```python\nfrom flask import Flask, Blueprint\n\napp = Flask(__name__)\n\nuser = Blueprint('user', __name__, url_prefix='/user')\n\n\n@user.route(\"/info/\", methods=['GET'])\ndef info():\n    return \"user info\"\n\n\n# 注意蓝图注册一定要在装饰函数之后, 不然蓝图没有装载函数, /user/info/ 就404错误了\n# 这里向 app 内部 blueprints 一个字典, 存储蓝图并将其 append,app._blueprint_order列表中. \napp.register_blueprint(user)\n\nif __name__ == '__main__':\n    app.run()\n\n```\n当一个请求进入的时候, url 会根据 _blueprint_order中的蓝图顺序进行匹配, 然后在blueprints找到对应得一级路由. 在创建蓝图时设置的 url_prefix, 在根据url 找到对应的endpoint 进入视图函数处理\n整个流程就是\n\n    request -> app -> blueprints -> blue -> endpoint -> view_func","source":"_posts/flask-路由和蓝图.md","raw":"---\ntitle: Flask 路由和蓝图\ndate: 2017-10-10 16:45:50\ntags: Flask, route, Blueprint\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Flask - Route - Blueprint\n\n在 flask 中创建路由是一件简单事情\n```python\nfrom flask import Flask, url_for\n\n\n# app 本质也可以看成一个蓝图\napp = Flask(__name__)\n\n# 定义路由\n@app.route('/', methods=['GET'])\ndef index():\n    return \"flask world\"\n\n# 方式二\napp.add_url_rule('/', 'index', index)   # 注意这种方式的endpoint 需要自己手动提供\n\n# route 内部做几件事情\n# 1. 根据参数, 决定这个函数的url路径, 并将这个url添加到 当前蓝图的url_map中\n# 2. 同时创建一个endpoint, 如果参数没有传递, 就将函数名作为endpoint, 好处就是当endpoint 作为函数id时, 在使用反向生成url会特别轻松\n# 3. url访问的流程就是 url -> app -> endpoint -> view_func\n\nurl = url_for('.index')     # 当前蓝图下面的index函数的url\n\n```\n\n而flask 中的蓝图使用\n```python\nfrom flask import Flask, Blueprint\n\napp = Flask(__name__)\n\nuser = Blueprint('user', __name__, url_prefix='/user')\n\n\n@user.route(\"/info/\", methods=['GET'])\ndef info():\n    return \"user info\"\n\n\n# 注意蓝图注册一定要在装饰函数之后, 不然蓝图没有装载函数, /user/info/ 就404错误了\n# 这里向 app 内部 blueprints 一个字典, 存储蓝图并将其 append,app._blueprint_order列表中. \napp.register_blueprint(user)\n\nif __name__ == '__main__':\n    app.run()\n\n```\n当一个请求进入的时候, url 会根据 _blueprint_order中的蓝图顺序进行匹配, 然后在blueprints找到对应得一级路由. 在创建蓝图时设置的 url_prefix, 在根据url 找到对应的endpoint 进入视图函数处理\n整个流程就是\n\n    request -> app -> blueprints -> blue -> endpoint -> view_func","slug":"flask-路由和蓝图","published":1,"updated":"2020-11-03T14:07:06.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje1000ro8t2gwepf865","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Flask-Route-Blueprint\"><a href=\"#Flask-Route-Blueprint\" class=\"headerlink\" title=\"Flask - Route - Blueprint\"></a>Flask - Route - Blueprint</h3><p>在 flask 中创建路由是一件简单事情</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, url_for</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># app 本质也可以看成一个蓝图</span></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义路由</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;flask world&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式二</span></span><br><span class=\"line\">app.add_url_rule(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"string\">&#x27;index&#x27;</span>, index)   <span class=\"comment\"># 注意这种方式的endpoint 需要自己手动提供</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># route 内部做几件事情</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 根据参数, 决定这个函数的url路径, 并将这个url添加到 当前蓝图的url_map中</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 同时创建一个endpoint, 如果参数没有传递, 就将函数名作为endpoint, 好处就是当endpoint 作为函数id时, 在使用反向生成url会特别轻松</span></span><br><span class=\"line\"><span class=\"comment\"># 3. url访问的流程就是 url -&gt; app -&gt; endpoint -&gt; view_func</span></span><br><span class=\"line\"></span><br><span class=\"line\">url = url_for(<span class=\"string\">&#x27;.index&#x27;</span>)     <span class=\"comment\"># 当前蓝图下面的index函数的url</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>而flask 中的蓝图使用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, Blueprint</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">user = Blueprint(<span class=\"string\">&#x27;user&#x27;</span>, __name__, url_prefix=<span class=\"string\">&#x27;/user&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@user.route(&quot;/info/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;user info&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意蓝图注册一定要在装饰函数之后, 不然蓝图没有装载函数, /user/info/ 就404错误了</span></span><br><span class=\"line\"><span class=\"comment\"># 这里向 app 内部 blueprints 一个字典, 存储蓝图并将其 append,app._blueprint_order列表中. </span></span><br><span class=\"line\">app.register_blueprint(user)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当一个请求进入的时候, url 会根据 _blueprint_order中的蓝图顺序进行匹配, 然后在blueprints找到对应得一级路由. 在创建蓝图时设置的 url_prefix, 在根据url 找到对应的endpoint 进入视图函数处理<br>整个流程就是</p>\n<pre><code>request -&gt; app -&gt; blueprints -&gt; blue -&gt; endpoint -&gt; view_func</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Flask-Route-Blueprint\"><a href=\"#Flask-Route-Blueprint\" class=\"headerlink\" title=\"Flask - Route - Blueprint\"></a>Flask - Route - Blueprint</h3><p>在 flask 中创建路由是一件简单事情</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, url_for</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># app 本质也可以看成一个蓝图</span></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义路由</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;flask world&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方式二</span></span><br><span class=\"line\">app.add_url_rule(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"string\">&#x27;index&#x27;</span>, index)   <span class=\"comment\"># 注意这种方式的endpoint 需要自己手动提供</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># route 内部做几件事情</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 根据参数, 决定这个函数的url路径, 并将这个url添加到 当前蓝图的url_map中</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 同时创建一个endpoint, 如果参数没有传递, 就将函数名作为endpoint, 好处就是当endpoint 作为函数id时, 在使用反向生成url会特别轻松</span></span><br><span class=\"line\"><span class=\"comment\"># 3. url访问的流程就是 url -&gt; app -&gt; endpoint -&gt; view_func</span></span><br><span class=\"line\"></span><br><span class=\"line\">url = url_for(<span class=\"string\">&#x27;.index&#x27;</span>)     <span class=\"comment\"># 当前蓝图下面的index函数的url</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>而flask 中的蓝图使用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, Blueprint</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">user = Blueprint(<span class=\"string\">&#x27;user&#x27;</span>, __name__, url_prefix=<span class=\"string\">&#x27;/user&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@user.route(&quot;/info/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;user info&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意蓝图注册一定要在装饰函数之后, 不然蓝图没有装载函数, /user/info/ 就404错误了</span></span><br><span class=\"line\"><span class=\"comment\"># 这里向 app 内部 blueprints 一个字典, 存储蓝图并将其 append,app._blueprint_order列表中. </span></span><br><span class=\"line\">app.register_blueprint(user)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当一个请求进入的时候, url 会根据 _blueprint_order中的蓝图顺序进行匹配, 然后在blueprints找到对应得一级路由. 在创建蓝图时设置的 url_prefix, 在根据url 找到对应的endpoint 进入视图函数处理<br>整个流程就是</p>\n<pre><code>request -&gt; app -&gt; blueprints -&gt; blue -&gt; endpoint -&gt; view_func</code></pre>\n"},{"title":"flask 上下文应用","date":"2017-10-11T09:53:41.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Flask 上下文的应用\n在flask 中存在两个上下文, request_context, app_context. 在项目中我们经常会用到. 哪么它们的底层原理是什么样的呢?\n答案在Flask.wsgi_app函数的源码中, 描述的很清楚. 当一个请求进入时, 会为这个请求创建一个request_context, 并将其推入stack 中. \n![flask_request_push_stack](/images/flask_request_push_stack.png)\n\n而 request_context 在push 函数里面, 可以清除的看到会先判断当前 _app_ctx_stack 栈顶是否存在当前app_context, 如果不存在就会创建一个app_context 并push到栈顶.\n哪么一个简单流程就是\n\n1. request -> app 时, create request context\n2. request_context.push()\n3. request_context.push 时会判断当前应用栈顶是否存在当前的应用上下文, 如果不存在就会创建并压入栈中.\n4. 执行整request_context push 操作\n5. 处理当前 request ctx 中session\n6. match_request() 函数url请求\n\n哪么 flask 为什么要使用这种方式来处理请求流程呢. 结合 flask.global 中的代码来解释就说的通了\n```python\n# context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\nrequest = LocalProxy(partial(_lookup_req_object, \"request\"))\nsession = LocalProxy(partial(_lookup_req_object, \"session\"))\ng = LocalProxy(partial(_lookup_app_object, \"g\"))\n\n``` \n在全局范围内有一个 _request_ctx_stack, _app_ctx_stack, 它们分别存储了当前请求的上下文环境. 哪么根据flask 支持的服务器并发模型, 主线程创建新连接, 子线程处理新连接.\n哪么势必有一个问题, 就是多线程的线程安全问题. 而flask 通过一个线程安全的LocalStack() 来隔离每个线程的上下文环境, 换句话讲就是每个线程有自己单独的数据存储区域. 而在LocalStack中\n使用了dict 并使用 threadId/greenletId 作为key, 存储不同线程的上下文环境. 注意这个地方才是最巧妙的. 也就是说Flask 在设计的时候就想到了可能需要通过greenlet方式实现并发, 哪么也就是说\n使用greenlet 作为底层支持的库, Flask都可以使用.\n所以经常在部署flask 的时候推荐, Gunicorn 使用 eventlet 或者 gevent 作为worker_class. 但是对于一些底层使用 c 编写的扩展, 对于greenlet 支持有限, 所以flask 生态对于并发可选择又不多.\n往往我们可能需要重新造轮子.\n\n哪么回到上下文的地方来, 还有另一个好处就是, 对于当前的request 对象和app 对象, 可以在请求周期的任何地方出现, 哪么在编写非视图函数的工具类当中, 直接引入request 和 current_app, 就是能够对当前请求的\n上下文做操作. 不得不说这样设计的巧妙. 但是,需要注意这两个对象都是通过代理模式拿到的对象, 如果需要对实际的对象做操作需要通过对象的 _get_current_object实例方法获取当前的对象.\n哪么session 对象和 g 对象的作用就不在详解了.","source":"_posts/flask上下文应用.md","raw":"---\ntitle: flask 上下文应用\ndate: 2017-10-11 17:53:41\ntags:\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Flask 上下文的应用\n在flask 中存在两个上下文, request_context, app_context. 在项目中我们经常会用到. 哪么它们的底层原理是什么样的呢?\n答案在Flask.wsgi_app函数的源码中, 描述的很清楚. 当一个请求进入时, 会为这个请求创建一个request_context, 并将其推入stack 中. \n![flask_request_push_stack](/images/flask_request_push_stack.png)\n\n而 request_context 在push 函数里面, 可以清除的看到会先判断当前 _app_ctx_stack 栈顶是否存在当前app_context, 如果不存在就会创建一个app_context 并push到栈顶.\n哪么一个简单流程就是\n\n1. request -> app 时, create request context\n2. request_context.push()\n3. request_context.push 时会判断当前应用栈顶是否存在当前的应用上下文, 如果不存在就会创建并压入栈中.\n4. 执行整request_context push 操作\n5. 处理当前 request ctx 中session\n6. match_request() 函数url请求\n\n哪么 flask 为什么要使用这种方式来处理请求流程呢. 结合 flask.global 中的代码来解释就说的通了\n```python\n# context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\nrequest = LocalProxy(partial(_lookup_req_object, \"request\"))\nsession = LocalProxy(partial(_lookup_req_object, \"session\"))\ng = LocalProxy(partial(_lookup_app_object, \"g\"))\n\n``` \n在全局范围内有一个 _request_ctx_stack, _app_ctx_stack, 它们分别存储了当前请求的上下文环境. 哪么根据flask 支持的服务器并发模型, 主线程创建新连接, 子线程处理新连接.\n哪么势必有一个问题, 就是多线程的线程安全问题. 而flask 通过一个线程安全的LocalStack() 来隔离每个线程的上下文环境, 换句话讲就是每个线程有自己单独的数据存储区域. 而在LocalStack中\n使用了dict 并使用 threadId/greenletId 作为key, 存储不同线程的上下文环境. 注意这个地方才是最巧妙的. 也就是说Flask 在设计的时候就想到了可能需要通过greenlet方式实现并发, 哪么也就是说\n使用greenlet 作为底层支持的库, Flask都可以使用.\n所以经常在部署flask 的时候推荐, Gunicorn 使用 eventlet 或者 gevent 作为worker_class. 但是对于一些底层使用 c 编写的扩展, 对于greenlet 支持有限, 所以flask 生态对于并发可选择又不多.\n往往我们可能需要重新造轮子.\n\n哪么回到上下文的地方来, 还有另一个好处就是, 对于当前的request 对象和app 对象, 可以在请求周期的任何地方出现, 哪么在编写非视图函数的工具类当中, 直接引入request 和 current_app, 就是能够对当前请求的\n上下文做操作. 不得不说这样设计的巧妙. 但是,需要注意这两个对象都是通过代理模式拿到的对象, 如果需要对实际的对象做操作需要通过对象的 _get_current_object实例方法获取当前的对象.\n哪么session 对象和 g 对象的作用就不在详解了.","slug":"flask上下文应用","published":1,"updated":"2020-11-03T14:07:06.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje2000to8t20xsb6mrg","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Flask-上下文的应用\"><a href=\"#Flask-上下文的应用\" class=\"headerlink\" title=\"Flask 上下文的应用\"></a>Flask 上下文的应用</h3><p>在flask 中存在两个上下文, request_context, app_context. 在项目中我们经常会用到. 哪么它们的底层原理是什么样的呢?<br>答案在Flask.wsgi_app函数的源码中, 描述的很清楚. 当一个请求进入时, 会为这个请求创建一个request_context, 并将其推入stack 中.<br><img src=\"/images/flask_request_push_stack.png\" alt=\"flask_request_push_stack\"></p>\n<p>而 request_context 在push 函数里面, 可以清除的看到会先判断当前 _app_ctx_stack 栈顶是否存在当前app_context, 如果不存在就会创建一个app_context 并push到栈顶.<br>哪么一个简单流程就是</p>\n<ol>\n<li>request -&gt; app 时, create request context</li>\n<li>request_context.push()</li>\n<li>request_context.push 时会判断当前应用栈顶是否存在当前的应用上下文, 如果不存在就会创建并压入栈中.</li>\n<li>执行整request_context push 操作</li>\n<li>处理当前 request ctx 中session</li>\n<li>match_request() 函数url请求</li>\n</ol>\n<p>哪么 flask 为什么要使用这种方式来处理请求流程呢. 结合 flask.global 中的代码来解释就说的通了</p>\n<pre><code class=\"python\"># context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\nrequest = LocalProxy(partial(_lookup_req_object, &quot;request&quot;))\nsession = LocalProxy(partial(_lookup_req_object, &quot;session&quot;))\ng = LocalProxy(partial(_lookup_app_object, &quot;g&quot;))\n</code></pre>\n<p>在全局范围内有一个 _request_ctx_stack, _app_ctx_stack, 它们分别存储了当前请求的上下文环境. 哪么根据flask 支持的服务器并发模型, 主线程创建新连接, 子线程处理新连接.<br>哪么势必有一个问题, 就是多线程的线程安全问题. 而flask 通过一个线程安全的LocalStack() 来隔离每个线程的上下文环境, 换句话讲就是每个线程有自己单独的数据存储区域. 而在LocalStack中<br>使用了dict 并使用 threadId/greenletId 作为key, 存储不同线程的上下文环境. 注意这个地方才是最巧妙的. 也就是说Flask 在设计的时候就想到了可能需要通过greenlet方式实现并发, 哪么也就是说<br>使用greenlet 作为底层支持的库, Flask都可以使用.<br>所以经常在部署flask 的时候推荐, Gunicorn 使用 eventlet 或者 gevent 作为worker_class. 但是对于一些底层使用 c 编写的扩展, 对于greenlet 支持有限, 所以flask 生态对于并发可选择又不多.<br>往往我们可能需要重新造轮子.</p>\n<p>哪么回到上下文的地方来, 还有另一个好处就是, 对于当前的request 对象和app 对象, 可以在请求周期的任何地方出现, 哪么在编写非视图函数的工具类当中, 直接引入request 和 current_app, 就是能够对当前请求的<br>上下文做操作. 不得不说这样设计的巧妙. 但是,需要注意这两个对象都是通过代理模式拿到的对象, 如果需要对实际的对象做操作需要通过对象的 _get_current_object实例方法获取当前的对象.<br>哪么session 对象和 g 对象的作用就不在详解了.</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Flask-上下文的应用\"><a href=\"#Flask-上下文的应用\" class=\"headerlink\" title=\"Flask 上下文的应用\"></a>Flask 上下文的应用</h3><p>在flask 中存在两个上下文, request_context, app_context. 在项目中我们经常会用到. 哪么它们的底层原理是什么样的呢?<br>答案在Flask.wsgi_app函数的源码中, 描述的很清楚. 当一个请求进入时, 会为这个请求创建一个request_context, 并将其推入stack 中.<br><img src=\"/images/flask_request_push_stack.png\" alt=\"flask_request_push_stack\"></p>\n<p>而 request_context 在push 函数里面, 可以清除的看到会先判断当前 _app_ctx_stack 栈顶是否存在当前app_context, 如果不存在就会创建一个app_context 并push到栈顶.<br>哪么一个简单流程就是</p>\n<ol>\n<li>request -&gt; app 时, create request context</li>\n<li>request_context.push()</li>\n<li>request_context.push 时会判断当前应用栈顶是否存在当前的应用上下文, 如果不存在就会创建并压入栈中.</li>\n<li>执行整request_context push 操作</li>\n<li>处理当前 request ctx 中session</li>\n<li>match_request() 函数url请求</li>\n</ol>\n<p>哪么 flask 为什么要使用这种方式来处理请求流程呢. 结合 flask.global 中的代码来解释就说的通了</p>\n<pre><code class=\"python\"># context locals\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\nrequest = LocalProxy(partial(_lookup_req_object, &quot;request&quot;))\nsession = LocalProxy(partial(_lookup_req_object, &quot;session&quot;))\ng = LocalProxy(partial(_lookup_app_object, &quot;g&quot;))\n</code></pre>\n<p>在全局范围内有一个 _request_ctx_stack, _app_ctx_stack, 它们分别存储了当前请求的上下文环境. 哪么根据flask 支持的服务器并发模型, 主线程创建新连接, 子线程处理新连接.<br>哪么势必有一个问题, 就是多线程的线程安全问题. 而flask 通过一个线程安全的LocalStack() 来隔离每个线程的上下文环境, 换句话讲就是每个线程有自己单独的数据存储区域. 而在LocalStack中<br>使用了dict 并使用 threadId/greenletId 作为key, 存储不同线程的上下文环境. 注意这个地方才是最巧妙的. 也就是说Flask 在设计的时候就想到了可能需要通过greenlet方式实现并发, 哪么也就是说<br>使用greenlet 作为底层支持的库, Flask都可以使用.<br>所以经常在部署flask 的时候推荐, Gunicorn 使用 eventlet 或者 gevent 作为worker_class. 但是对于一些底层使用 c 编写的扩展, 对于greenlet 支持有限, 所以flask 生态对于并发可选择又不多.<br>往往我们可能需要重新造轮子.</p>\n<p>哪么回到上下文的地方来, 还有另一个好处就是, 对于当前的request 对象和app 对象, 可以在请求周期的任何地方出现, 哪么在编写非视图函数的工具类当中, 直接引入request 和 current_app, 就是能够对当前请求的<br>上下文做操作. 不得不说这样设计的巧妙. 但是,需要注意这两个对象都是通过代理模式拿到的对象, 如果需要对实际的对象做操作需要通过对象的 _get_current_object实例方法获取当前的对象.<br>哪么session 对象和 g 对象的作用就不在详解了.</p>\n"},{"title":"flask模板使用","date":"2017-10-10T10:26:17.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask 模板使用\nFlask 模板在jinja2 库之上进行一层封装, 便于在flask 中使用\n而我们要想使用jinja2 所提供的完整功能, 可以根据需要查看官方文档. \n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n\n# 渲染模板\n@app.route(\"/\", methods=['GET'])\ndef index():\n    return render_template(\"index.html\")\n\n\nif __name__ == '__main__':\n    app.run()\n```\n有两个地方要注意\n1. 存放模板文件的目录有两种方式\n    * 模板与app 所在脚本在同一级目录\n    * 模板目录是应用模块子目录\n2. 在pycharm 中最好显示声明一下template folder\n\njinja2 解决了特殊字符转义功能, 这个在对于一些不安全的字符和xss处理上很有帮助. \n下面演示一些常见的模板语法\n```jinja2\n{{ title }} {# 模板变量使用#}\n\n{#模板语法#}\n{% for item in users%}\n    {{ item }}\n{% endfor %}\n\n{# if 语法#}\n{% if item.bool %}\n    {# if 语法实现 #}\n\n{% endif%}\n```\n当然这些还不能体现这个框架和flask 结合的强大之处, 哪么现在我们来看一下flash() 在下一次请求中获取上次一响应的消息, 咋一看挺绕的.\n使用这个工具需要在模板中使用 get_flashed_messages() 获取传递的数据.\n```python\nfrom flask import Flask, render_template, flash\n\napp = Flask(__name__)\n\n\n# 渲染模板\n@app.route(\"/\", methods=['GET'])\ndef index():\n    flash(\"hello flask\")\n    return render_template(\"index.html\")\n\n\nif __name__ == '__main__':\n    app.run()\n```","source":"_posts/flask模板使用.md","raw":"---\ntitle: flask模板使用\ndate: 2017-10-10 18:26:17\ntags: Flask, template\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n## Flask 模板使用\nFlask 模板在jinja2 库之上进行一层封装, 便于在flask 中使用\n而我们要想使用jinja2 所提供的完整功能, 可以根据需要查看官方文档. \n\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n\n# 渲染模板\n@app.route(\"/\", methods=['GET'])\ndef index():\n    return render_template(\"index.html\")\n\n\nif __name__ == '__main__':\n    app.run()\n```\n有两个地方要注意\n1. 存放模板文件的目录有两种方式\n    * 模板与app 所在脚本在同一级目录\n    * 模板目录是应用模块子目录\n2. 在pycharm 中最好显示声明一下template folder\n\njinja2 解决了特殊字符转义功能, 这个在对于一些不安全的字符和xss处理上很有帮助. \n下面演示一些常见的模板语法\n```jinja2\n{{ title }} {# 模板变量使用#}\n\n{#模板语法#}\n{% for item in users%}\n    {{ item }}\n{% endfor %}\n\n{# if 语法#}\n{% if item.bool %}\n    {# if 语法实现 #}\n\n{% endif%}\n```\n当然这些还不能体现这个框架和flask 结合的强大之处, 哪么现在我们来看一下flash() 在下一次请求中获取上次一响应的消息, 咋一看挺绕的.\n使用这个工具需要在模板中使用 get_flashed_messages() 获取传递的数据.\n```python\nfrom flask import Flask, render_template, flash\n\napp = Flask(__name__)\n\n\n# 渲染模板\n@app.route(\"/\", methods=['GET'])\ndef index():\n    flash(\"hello flask\")\n    return render_template(\"index.html\")\n\n\nif __name__ == '__main__':\n    app.run()\n```","slug":"flask模板使用","published":1,"updated":"2020-11-03T14:07:06.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje4000vo8t2gcdk4a9l","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-模板使用\"><a href=\"#Flask-模板使用\" class=\"headerlink\" title=\"Flask 模板使用\"></a>Flask 模板使用</h2><p>Flask 模板在jinja2 库之上进行一层封装, 便于在flask 中使用<br>而我们要想使用jinja2 所提供的完整功能, 可以根据需要查看官方文档. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, render_template</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 渲染模板</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&quot;index.html&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>有两个地方要注意</p>\n<ol>\n<li>存放模板文件的目录有两种方式<ul>\n<li>模板与app 所在脚本在同一级目录</li>\n<li>模板目录是应用模块子目录</li>\n</ul>\n</li>\n<li>在pycharm 中最好显示声明一下template folder</li>\n</ol>\n<p>jinja2 解决了特殊字符转义功能, 这个在对于一些不安全的字符和xss处理上很有帮助.<br>下面演示一些常见的模板语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; title &#125;&#125; &#123;# 模板变量使用#&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#模板语法#&#125;</span><br><span class=\"line\">&#123;% for item in users%&#125;</span><br><span class=\"line\">    &#123;&#123; item &#125;&#125;</span><br><span class=\"line\">&#123;% endfor %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;# if 语法#&#125;</span><br><span class=\"line\">&#123;% if item.bool %&#125;</span><br><span class=\"line\">    &#123;# if 语法实现 #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif%&#125;</span><br></pre></td></tr></table></figure>\n<p>当然这些还不能体现这个框架和flask 结合的强大之处, 哪么现在我们来看一下flash() 在下一次请求中获取上次一响应的消息, 咋一看挺绕的.<br>使用这个工具需要在模板中使用 get_flashed_messages() 获取传递的数据.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, render_template, flash</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 渲染模板</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    flash(<span class=\"string\">&quot;hello flask&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&quot;index.html&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"Flask-模板使用\"><a href=\"#Flask-模板使用\" class=\"headerlink\" title=\"Flask 模板使用\"></a>Flask 模板使用</h2><p>Flask 模板在jinja2 库之上进行一层封装, 便于在flask 中使用<br>而我们要想使用jinja2 所提供的完整功能, 可以根据需要查看官方文档. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, render_template</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 渲染模板</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&quot;index.html&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>有两个地方要注意</p>\n<ol>\n<li>存放模板文件的目录有两种方式<ul>\n<li>模板与app 所在脚本在同一级目录</li>\n<li>模板目录是应用模块子目录</li>\n</ul>\n</li>\n<li>在pycharm 中最好显示声明一下template folder</li>\n</ol>\n<p>jinja2 解决了特殊字符转义功能, 这个在对于一些不安全的字符和xss处理上很有帮助.<br>下面演示一些常见的模板语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; title &#125;&#125; &#123;# 模板变量使用#&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;#模板语法#&#125;</span><br><span class=\"line\">&#123;% for item in users%&#125;</span><br><span class=\"line\">    &#123;&#123; item &#125;&#125;</span><br><span class=\"line\">&#123;% endfor %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;# if 语法#&#125;</span><br><span class=\"line\">&#123;% if item.bool %&#125;</span><br><span class=\"line\">    &#123;# if 语法实现 #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endif%&#125;</span><br></pre></td></tr></table></figure>\n<p>当然这些还不能体现这个框架和flask 结合的强大之处, 哪么现在我们来看一下flash() 在下一次请求中获取上次一响应的消息, 咋一看挺绕的.<br>使用这个工具需要在模板中使用 get_flashed_messages() 获取传递的数据.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, render_template, flash</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 渲染模板</span></span><br><span class=\"line\"><span class=\"meta\">@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span>():</span></span><br><span class=\"line\">    flash(<span class=\"string\">&quot;hello flask&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&quot;index.html&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>"},{"title":"linux TCP参数说明","date":"2018-08-20T14:57:09.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Linux TCP 系统平台上的参数, 往往在特殊情况下, 需要根据自身业务进行调整. 这样才能发挥出机器在当前业务下的性能峰值\n所以我们需要对这些参数有一定认识:\n\nnet.ipv4:\n* 基本参数:\n    * tcp_syn_retries 内核发送多少个SYN数据包会放弃该链接, 对应TCP 第一次握手阶段\n    * tcp_synack_retries  内核发送多少个SYN + ACK, 才会放弃连接\n    * tcp_keepalive_time tcp 发送keepalive 数据包频率, 默认2小时.","source":"_posts/linux-TCP参数说明.md","raw":"---\ntitle: linux TCP参数说明\ndate: 2018-8-20 22:57:09\ntags: TCP, Linux\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Linux TCP 系统平台上的参数, 往往在特殊情况下, 需要根据自身业务进行调整. 这样才能发挥出机器在当前业务下的性能峰值\n所以我们需要对这些参数有一定认识:\n\nnet.ipv4:\n* 基本参数:\n    * tcp_syn_retries 内核发送多少个SYN数据包会放弃该链接, 对应TCP 第一次握手阶段\n    * tcp_synack_retries  内核发送多少个SYN + ACK, 才会放弃连接\n    * tcp_keepalive_time tcp 发送keepalive 数据包频率, 默认2小时.","slug":"linux-TCP参数说明","published":1,"updated":"2020-11-03T14:07:06.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje5000xo8t2b6q51h3o","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Linux-TCP-系统平台上的参数-往往在特殊情况下-需要根据自身业务进行调整-这样才能发挥出机器在当前业务下的性能峰值\"><a href=\"#Linux-TCP-系统平台上的参数-往往在特殊情况下-需要根据自身业务进行调整-这样才能发挥出机器在当前业务下的性能峰值\" class=\"headerlink\" title=\"Linux TCP 系统平台上的参数, 往往在特殊情况下, 需要根据自身业务进行调整. 这样才能发挥出机器在当前业务下的性能峰值\"></a>Linux TCP 系统平台上的参数, 往往在特殊情况下, 需要根据自身业务进行调整. 这样才能发挥出机器在当前业务下的性能峰值</h3><p>所以我们需要对这些参数有一定认识:</p>\n<p>net.ipv4:</p>\n<ul>\n<li>基本参数:<ul>\n<li>tcp_syn_retries 内核发送多少个SYN数据包会放弃该链接, 对应TCP 第一次握手阶段</li>\n<li>tcp_synack_retries  内核发送多少个SYN + ACK, 才会放弃连接</li>\n<li>tcp_keepalive_time tcp 发送keepalive 数据包频率, 默认2小时.</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Linux-TCP-系统平台上的参数-往往在特殊情况下-需要根据自身业务进行调整-这样才能发挥出机器在当前业务下的性能峰值\"><a href=\"#Linux-TCP-系统平台上的参数-往往在特殊情况下-需要根据自身业务进行调整-这样才能发挥出机器在当前业务下的性能峰值\" class=\"headerlink\" title=\"Linux TCP 系统平台上的参数, 往往在特殊情况下, 需要根据自身业务进行调整. 这样才能发挥出机器在当前业务下的性能峰值\"></a>Linux TCP 系统平台上的参数, 往往在特殊情况下, 需要根据自身业务进行调整. 这样才能发挥出机器在当前业务下的性能峰值</h3><p>所以我们需要对这些参数有一定认识:</p>\n<p>net.ipv4:</p>\n<ul>\n<li>基本参数:<ul>\n<li>tcp_syn_retries 内核发送多少个SYN数据包会放弃该链接, 对应TCP 第一次握手阶段</li>\n<li>tcp_synack_retries  内核发送多少个SYN + ACK, 才会放弃连接</li>\n<li>tcp_keepalive_time tcp 发送keepalive 数据包频率, 默认2小时.</li>\n</ul>\n</li>\n</ul>\n"},{"title":"python gc","date":"2018-10-21T11:19:27.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n## python 的内存管理机制\n\n对python有一定程度了解的人都知道, python自带内存管理机制. 通过一定策略对内存进行回收, 让程序员不至于经历手动回收的痛苦,但往往带自动gc功能的语言\n都会不同程度的出现内存泄漏问题, 从导致内存溢出. 在笔者的开发中, celery这个库, 不经过参数调整, 很容易出现内存问题.\n\npython内存管理机制:\n    1. 引用计数\n        最简单明了的内存管理方法, 对分配内存的对象增加一个计数器, 如果计数器变成0.哪么这个对象就准备被gc回收\n       \n    2. 循环引用\n        基于\n    3. 标记清除\n        ","source":"_posts/python-gc.md","raw":"---\ntitle: python gc\ndate: 2018-10-21 19:19:27\ntags: python, gc, 内存管理\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n## python 的内存管理机制\n\n对python有一定程度了解的人都知道, python自带内存管理机制. 通过一定策略对内存进行回收, 让程序员不至于经历手动回收的痛苦,但往往带自动gc功能的语言\n都会不同程度的出现内存泄漏问题, 从导致内存溢出. 在笔者的开发中, celery这个库, 不经过参数调整, 很容易出现内存问题.\n\npython内存管理机制:\n    1. 引用计数\n        最简单明了的内存管理方法, 对分配内存的对象增加一个计数器, 如果计数器变成0.哪么这个对象就准备被gc回收\n       \n    2. 循环引用\n        基于\n    3. 标记清除\n        ","slug":"python-gc","published":1,"updated":"2020-11-03T14:07:06.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje6000yo8t2hi8e7zls","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"python-的内存管理机制\"><a href=\"#python-的内存管理机制\" class=\"headerlink\" title=\"python 的内存管理机制\"></a>python 的内存管理机制</h2><p>对python有一定程度了解的人都知道, python自带内存管理机制. 通过一定策略对内存进行回收, 让程序员不至于经历手动回收的痛苦,但往往带自动gc功能的语言<br>都会不同程度的出现内存泄漏问题, 从导致内存溢出. 在笔者的开发中, celery这个库, 不经过参数调整, 很容易出现内存问题.</p>\n<p>python内存管理机制:<br>    1. 引用计数<br>        最简单明了的内存管理方法, 对分配内存的对象增加一个计数器, 如果计数器变成0.哪么这个对象就准备被gc回收</p>\n<pre><code>2. 循环引用\n    基于\n3. 标记清除</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"python-的内存管理机制\"><a href=\"#python-的内存管理机制\" class=\"headerlink\" title=\"python 的内存管理机制\"></a>python 的内存管理机制</h2><p>对python有一定程度了解的人都知道, python自带内存管理机制. 通过一定策略对内存进行回收, 让程序员不至于经历手动回收的痛苦,但往往带自动gc功能的语言<br>都会不同程度的出现内存泄漏问题, 从导致内存溢出. 在笔者的开发中, celery这个库, 不经过参数调整, 很容易出现内存问题.</p>\n<p>python内存管理机制:<br>    1. 引用计数<br>        最简单明了的内存管理方法, 对分配内存的对象增加一个计数器, 如果计数器变成0.哪么这个对象就准备被gc回收</p>\n<pre><code>2. 循环引用\n    基于\n3. 标记清除</code></pre>\n"},{"title":"mysql数据库主从","date":"2017-10-21T07:42:45.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Mysql 主从\nmysql 主从配置, 从根本上解决了读写分离的问题. 而读写分离是因为数据库应对并发的读写操作时, 应该将两种操作分离.因为读和写操作的io消耗不是一个程度量级.\n\n哪么如何在架构中实现这样的功能呢.\n    1. 在应用层做sql路由实现读写分离\n    2. 在mysql 之间配置主从\n   \n   \n### mysql master config\nmysqld.ini\n\n\n\n### mysql salve config\nmysqld.ini","source":"_posts/mysql数据库主从.md","raw":"---\ntitle: mysql数据库主从\ndate: 2017-10-21 15:42:45\ntags: Mysql, 主从\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Mysql 主从\nmysql 主从配置, 从根本上解决了读写分离的问题. 而读写分离是因为数据库应对并发的读写操作时, 应该将两种操作分离.因为读和写操作的io消耗不是一个程度量级.\n\n哪么如何在架构中实现这样的功能呢.\n    1. 在应用层做sql路由实现读写分离\n    2. 在mysql 之间配置主从\n   \n   \n### mysql master config\nmysqld.ini\n\n\n\n### mysql salve config\nmysqld.ini","slug":"mysql数据库主从","published":1,"updated":"2020-11-03T14:07:06.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje70011o8t2dbvy2dc5","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Mysql-主从\"><a href=\"#Mysql-主从\" class=\"headerlink\" title=\"Mysql 主从\"></a>Mysql 主从</h3><p>mysql 主从配置, 从根本上解决了读写分离的问题. 而读写分离是因为数据库应对并发的读写操作时, 应该将两种操作分离.因为读和写操作的io消耗不是一个程度量级.</p>\n<p>哪么如何在架构中实现这样的功能呢.<br>    1. 在应用层做sql路由实现读写分离<br>    2. 在mysql 之间配置主从</p>\n<h3 id=\"mysql-master-config\"><a href=\"#mysql-master-config\" class=\"headerlink\" title=\"mysql master config\"></a>mysql master config</h3><p>mysqld.ini</p>\n<h3 id=\"mysql-salve-config\"><a href=\"#mysql-salve-config\" class=\"headerlink\" title=\"mysql salve config\"></a>mysql salve config</h3><p>mysqld.ini</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Mysql-主从\"><a href=\"#Mysql-主从\" class=\"headerlink\" title=\"Mysql 主从\"></a>Mysql 主从</h3><p>mysql 主从配置, 从根本上解决了读写分离的问题. 而读写分离是因为数据库应对并发的读写操作时, 应该将两种操作分离.因为读和写操作的io消耗不是一个程度量级.</p>\n<p>哪么如何在架构中实现这样的功能呢.<br>    1. 在应用层做sql路由实现读写分离<br>    2. 在mysql 之间配置主从</p>\n<h3 id=\"mysql-master-config\"><a href=\"#mysql-master-config\" class=\"headerlink\" title=\"mysql master config\"></a>mysql master config</h3><p>mysqld.ini</p>\n<h3 id=\"mysql-salve-config\"><a href=\"#mysql-salve-config\" class=\"headerlink\" title=\"mysql salve config\"></a>mysql salve config</h3><p>mysqld.ini</p>\n"},{"title":"python 中的 dataclasses","date":"2017-06-17T15:20:24.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### python 中原来也有类似kotlin 中 dataclass\n\n```python\nfrom dataclasses import dataclass\n\n```","source":"_posts/python-中的-dataclasses.md","raw":"---\ntitle: python 中的 dataclasses\ndate: 2017-06-17 23:20:24\ntags: python\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### python 中原来也有类似kotlin 中 dataclass\n\n```python\nfrom dataclasses import dataclass\n\n```","slug":"python-中的-dataclasses","published":1,"updated":"2020-11-03T14:07:06.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsje90012o8t2fz0fd9p9","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"python-中原来也有类似kotlin-中-dataclass\"><a href=\"#python-中原来也有类似kotlin-中-dataclass\" class=\"headerlink\" title=\"python 中原来也有类似kotlin 中 dataclass\"></a>python 中原来也有类似kotlin 中 dataclass</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> dataclasses <span class=\"keyword\">import</span> dataclass</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"python-中原来也有类似kotlin-中-dataclass\"><a href=\"#python-中原来也有类似kotlin-中-dataclass\" class=\"headerlink\" title=\"python 中原来也有类似kotlin 中 dataclass\"></a>python 中原来也有类似kotlin 中 dataclass</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> dataclasses <span class=\"keyword\">import</span> dataclass</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"python 内存泄漏问题","date":"2018-10-18T07:41:17.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### Python Memory Leak\n\n内存泄漏, 是指在程序运行期间, 动态分配的堆上内存没有被正常释放, 导致内存无法回收. 一直到内存资源耗尽为止\n在程序中屡见不鲜. 当我在编写自己的工具类或者, 定义具有magic method的类时\n另一种情况就是, 在程序中申请的资源没有被及时的释放. 导致对象引用存在, 内存资源也就无法被释放.\n\n##### Python Memory 查看工具:\n1. \n\n\n2 tracema","source":"_posts/python-内存泄漏问题.md","raw":"---\ntitle: python 内存泄漏问题\ndate: 2018-10-18 15:41:17\ntags: Python, Memory\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n#### Python Memory Leak\n\n内存泄漏, 是指在程序运行期间, 动态分配的堆上内存没有被正常释放, 导致内存无法回收. 一直到内存资源耗尽为止\n在程序中屡见不鲜. 当我在编写自己的工具类或者, 定义具有magic method的类时\n另一种情况就是, 在程序中申请的资源没有被及时的释放. 导致对象引用存在, 内存资源也就无法被释放.\n\n##### Python Memory 查看工具:\n1. \n\n\n2 tracema","slug":"python-内存泄漏问题","published":1,"updated":"2020-11-04T03:23:51.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjea0014o8t24kl09rq9","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"Python-Memory-Leak\"><a href=\"#Python-Memory-Leak\" class=\"headerlink\" title=\"Python Memory Leak\"></a>Python Memory Leak</h4><p>内存泄漏, 是指在程序运行期间, 动态分配的堆上内存没有被正常释放, 导致内存无法回收. 一直到内存资源耗尽为止<br>在程序中屡见不鲜. 当我在编写自己的工具类或者, 定义具有magic method的类时<br>另一种情况就是, 在程序中申请的资源没有被及时的释放. 导致对象引用存在, 内存资源也就无法被释放.</p>\n<h5 id=\"Python-Memory-查看工具\"><a href=\"#Python-Memory-查看工具\" class=\"headerlink\" title=\"Python Memory 查看工具:\"></a>Python Memory 查看工具:</h5><ol>\n<li></li>\n</ol>\n<p>2 tracema</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h4 id=\"Python-Memory-Leak\"><a href=\"#Python-Memory-Leak\" class=\"headerlink\" title=\"Python Memory Leak\"></a>Python Memory Leak</h4><p>内存泄漏, 是指在程序运行期间, 动态分配的堆上内存没有被正常释放, 导致内存无法回收. 一直到内存资源耗尽为止<br>在程序中屡见不鲜. 当我在编写自己的工具类或者, 定义具有magic method的类时<br>另一种情况就是, 在程序中申请的资源没有被及时的释放. 导致对象引用存在, 内存资源也就无法被释放.</p>\n<h5 id=\"Python-Memory-查看工具\"><a href=\"#Python-Memory-查看工具\" class=\"headerlink\" title=\"Python Memory 查看工具:\"></a>Python Memory 查看工具:</h5><ol>\n<li></li>\n</ol>\n<p>2 tracema</p>\n"},{"title":"Redis 基本数据结构之String","date":"2017-10-21T05:17:22.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Redis 基本数据结构之String\n\n当我们引入一个技术的同时, 首先应该考虑一下这个技术引入的成本:\n\n1. 学习成本\n2. 开发效率成本\n3. 价值成本\n4. 运维相关的成本\n    \n这些东西虽然只有1, 2条和开发人员相关. 但是如果我们想得到长期发展, 就必须从一个管理或者组织者的角度去看问题. 引入的技术栈的时候应该多做权衡和取舍.\n本文不会像官方文档那样, 一步一步介绍redis 的相关命令, 而是从实际业务出发去使用相对应的数据结构.\n\n##### example1\n  先来一个热身, redis string 数据结构\n  在使用之前, 我们必须要对这个数据结构的一些属性有所了解\n  \n  1. string数据结构存储的数据类型可以是字符串, 也可以是二进制数据\n  2. string最大存储512mb 的数据大小\n  \n根据这些特点我们可以实现一些功能\n  \n  1. 用作用户状态保持\n      * 一般用户状态可以, 转换成字符串形式, 保存在redis当中.\n      ```\n        set user:{id}:session: value expire\n     ```\n      \n  2. 用作缓存\n      * 比如博客, 用title或者作者做key, 内容存入redis string中.\n      * 比如一个函数的执行结果, 保存在string中\n      * 验证码存储\n      ```\n        set cache:{objectType}:{objectName}:{id} value expire\n     ```\n      \n  3. lock实现:\n      * 在多台服务器的情况下, 对一个数据的并发修改, 势必需要引入某种同步机制. 分布式锁实现\n      ```\n        set key value nx // 当key存在的时候key是无法设置成功的， 就好像去拿锁一样， 存在就需要阻塞。\n        \n        set key value ex[second]|px[milliseconds] nx // 当设置lock机器故障的时候, lock需要释放, 这个时候超时机制就很有必要了\n        \n         \n     ```\n  \n  4. 原子操作:\n      * redis 内部提供的原子操作, incr. 比如在并发场景下, 针对秒杀商品通过提前载入商品数据, 在业务期间.通过原子递增的特性\n      保证商品数据的竞争安全. 结合queue实现秒杀业务下单逻辑\n      ```\n         \n     ```\n      \n      * 同时也可以当作计数器使用, 比如某个文章的阅读次数, 某个商品的浏览次数\n","source":"_posts/redis-基本数据结构-string.md","raw":"---\ntitle: Redis 基本数据结构之String\ndate: 2017-10-21 13:17:22\ntags: Redis\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Redis 基本数据结构之String\n\n当我们引入一个技术的同时, 首先应该考虑一下这个技术引入的成本:\n\n1. 学习成本\n2. 开发效率成本\n3. 价值成本\n4. 运维相关的成本\n    \n这些东西虽然只有1, 2条和开发人员相关. 但是如果我们想得到长期发展, 就必须从一个管理或者组织者的角度去看问题. 引入的技术栈的时候应该多做权衡和取舍.\n本文不会像官方文档那样, 一步一步介绍redis 的相关命令, 而是从实际业务出发去使用相对应的数据结构.\n\n##### example1\n  先来一个热身, redis string 数据结构\n  在使用之前, 我们必须要对这个数据结构的一些属性有所了解\n  \n  1. string数据结构存储的数据类型可以是字符串, 也可以是二进制数据\n  2. string最大存储512mb 的数据大小\n  \n根据这些特点我们可以实现一些功能\n  \n  1. 用作用户状态保持\n      * 一般用户状态可以, 转换成字符串形式, 保存在redis当中.\n      ```\n        set user:{id}:session: value expire\n     ```\n      \n  2. 用作缓存\n      * 比如博客, 用title或者作者做key, 内容存入redis string中.\n      * 比如一个函数的执行结果, 保存在string中\n      * 验证码存储\n      ```\n        set cache:{objectType}:{objectName}:{id} value expire\n     ```\n      \n  3. lock实现:\n      * 在多台服务器的情况下, 对一个数据的并发修改, 势必需要引入某种同步机制. 分布式锁实现\n      ```\n        set key value nx // 当key存在的时候key是无法设置成功的， 就好像去拿锁一样， 存在就需要阻塞。\n        \n        set key value ex[second]|px[milliseconds] nx // 当设置lock机器故障的时候, lock需要释放, 这个时候超时机制就很有必要了\n        \n         \n     ```\n  \n  4. 原子操作:\n      * redis 内部提供的原子操作, incr. 比如在并发场景下, 针对秒杀商品通过提前载入商品数据, 在业务期间.通过原子递增的特性\n      保证商品数据的竞争安全. 结合queue实现秒杀业务下单逻辑\n      ```\n         \n     ```\n      \n      * 同时也可以当作计数器使用, 比如某个文章的阅读次数, 某个商品的浏览次数\n","slug":"redis-基本数据结构-string","published":1,"updated":"2020-11-04T03:23:25.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjeb0016o8t2024k0ftd","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Redis-基本数据结构之String\"><a href=\"#Redis-基本数据结构之String\" class=\"headerlink\" title=\"Redis 基本数据结构之String\"></a>Redis 基本数据结构之String</h3><p>当我们引入一个技术的同时, 首先应该考虑一下这个技术引入的成本:</p>\n<ol>\n<li>学习成本</li>\n<li>开发效率成本</li>\n<li>价值成本</li>\n<li>运维相关的成本</li>\n</ol>\n<p>这些东西虽然只有1, 2条和开发人员相关. 但是如果我们想得到长期发展, 就必须从一个管理或者组织者的角度去看问题. 引入的技术栈的时候应该多做权衡和取舍.<br>本文不会像官方文档那样, 一步一步介绍redis 的相关命令, 而是从实际业务出发去使用相对应的数据结构.</p>\n<h5 id=\"example1\"><a href=\"#example1\" class=\"headerlink\" title=\"example1\"></a>example1</h5><p>  先来一个热身, redis string 数据结构<br>  在使用之前, 我们必须要对这个数据结构的一些属性有所了解</p>\n<ol>\n<li>string数据结构存储的数据类型可以是字符串, 也可以是二进制数据</li>\n<li>string最大存储512mb 的数据大小</li>\n</ol>\n<p>根据这些特点我们可以实现一些功能</p>\n<ol>\n<li><p>用作用户状态保持</p>\n<ul>\n<li>一般用户状态可以, 转换成字符串形式, 保存在redis当中.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set user:&#123;id&#125;:session: value expire</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>用作缓存</p>\n<ul>\n<li>比如博客, 用title或者作者做key, 内容存入redis string中.</li>\n<li>比如一个函数的执行结果, 保存在string中</li>\n<li>验证码存储<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set cache:&#123;objectType&#125;:&#123;objectName&#125;:&#123;id&#125; value expire</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>lock实现:</p>\n<ul>\n<li>在多台服务器的情况下, 对一个数据的并发修改, 势必需要引入某种同步机制. 分布式锁实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set key value nx &#x2F;&#x2F; 当key存在的时候key是无法设置成功的， 就好像去拿锁一样， 存在就需要阻塞。</span><br><span class=\"line\"></span><br><span class=\"line\">set key value ex[second]|px[milliseconds] nx &#x2F;&#x2F; 当设置lock机器故障的时候, lock需要释放, 这个时候超时机制就很有必要了</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>原子操作:</p>\n<ul>\n<li><p>redis 内部提供的原子操作, incr. 比如在并发场景下, 针对秒杀商品通过提前载入商品数据, 在业务期间.通过原子递增的特性<br>保证商品数据的竞争安全. 结合queue实现秒杀业务下单逻辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同时也可以当作计数器使用, 比如某个文章的阅读次数, 某个商品的浏览次数</p>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Redis-基本数据结构之String\"><a href=\"#Redis-基本数据结构之String\" class=\"headerlink\" title=\"Redis 基本数据结构之String\"></a>Redis 基本数据结构之String</h3><p>当我们引入一个技术的同时, 首先应该考虑一下这个技术引入的成本:</p>\n<ol>\n<li>学习成本</li>\n<li>开发效率成本</li>\n<li>价值成本</li>\n<li>运维相关的成本</li>\n</ol>\n<p>这些东西虽然只有1, 2条和开发人员相关. 但是如果我们想得到长期发展, 就必须从一个管理或者组织者的角度去看问题. 引入的技术栈的时候应该多做权衡和取舍.<br>本文不会像官方文档那样, 一步一步介绍redis 的相关命令, 而是从实际业务出发去使用相对应的数据结构.</p>\n<h5 id=\"example1\"><a href=\"#example1\" class=\"headerlink\" title=\"example1\"></a>example1</h5><p>  先来一个热身, redis string 数据结构<br>  在使用之前, 我们必须要对这个数据结构的一些属性有所了解</p>\n<ol>\n<li>string数据结构存储的数据类型可以是字符串, 也可以是二进制数据</li>\n<li>string最大存储512mb 的数据大小</li>\n</ol>\n<p>根据这些特点我们可以实现一些功能</p>\n<ol>\n<li><p>用作用户状态保持</p>\n<ul>\n<li>一般用户状态可以, 转换成字符串形式, 保存在redis当中.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set user:&#123;id&#125;:session: value expire</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>用作缓存</p>\n<ul>\n<li>比如博客, 用title或者作者做key, 内容存入redis string中.</li>\n<li>比如一个函数的执行结果, 保存在string中</li>\n<li>验证码存储<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set cache:&#123;objectType&#125;:&#123;objectName&#125;:&#123;id&#125; value expire</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>lock实现:</p>\n<ul>\n<li>在多台服务器的情况下, 对一个数据的并发修改, 势必需要引入某种同步机制. 分布式锁实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set key value nx &#x2F;&#x2F; 当key存在的时候key是无法设置成功的， 就好像去拿锁一样， 存在就需要阻塞。</span><br><span class=\"line\"></span><br><span class=\"line\">set key value ex[second]|px[milliseconds] nx &#x2F;&#x2F; 当设置lock机器故障的时候, lock需要释放, 这个时候超时机制就很有必要了</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>原子操作:</p>\n<ul>\n<li><p>redis 内部提供的原子操作, incr. 比如在并发场景下, 针对秒杀商品通过提前载入商品数据, 在业务期间.通过原子递增的特性<br>保证商品数据的竞争安全. 结合queue实现秒杀业务下单逻辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同时也可以当作计数器使用, 比如某个文章的阅读次数, 某个商品的浏览次数</p>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"python包打包分发","date":"2018-09-03T12:53:11.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n# python 包的打包与构建\n由于python的源码都是开源的形式, 而有的时候我们在传输文件的时候又希望直接传递一个文件就可以.\n或者将我们自己编写的python分发给其他人使用, 这个时候我们就需要对自己编写的python 包进行build打包\n具体操作如下\n1. 在项目目录下建立文件:\n```\npackaging_tutorial\n├── LICENSE\n├── README.md\n├── example_pkg\n│   └── __init__.py\n├── setup.py\n└── tests\n```\n* license 用来指明这个包遵循什么样的开源许可证\n* readme 告诉别人这个包的一些信息\n* example_pkg 则是这个包的实际代码\n* test 是这个包的test用例代码\n* setup.py 用来build 包的脚本\n\n在整个build过程中我们只需要编写setup.py 中的一些信息即可\n```python\nfrom setuptools import setup\n# setup\nsetup(\n    name='sample',   # 用于在pypi上面显示的名字\n    version='1.2.0',    # 项目的当前版本\n    description='A sample Python project',\n    long_description='',\n    long_description_content_type='text/x-rst', \n    url='https://github.com/xxxx/sampleproject',    # 项目的托管地址\n    author='A. Random Developer',\n    author_email='author@example.com',\n    license='MIT',\n    keywords='sample setuptools development', #用于此项目的搜索关键字\n    install_requires=['peppercorn'],    # 此项目的依赖\n    python_requires='>=3',          # 支持的python 版本\n    # 还有许多暂时用不到的选项...\n)\n\n```\n\n* 然后通过python 执行setup, 就会在当前工程下, dist目录创建一个tar格式的压缩包.\n```\npython setup.py sdist\n```\n* 如果需要打包成wheel\n```\npip install wheel\npython setup.py bdist_wheel\n```\n","source":"_posts/python包打包分发.md","raw":"---\ntitle: python包打包分发\ndate: 2018-09-03 20:53:11\ntags: build\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n# python 包的打包与构建\n由于python的源码都是开源的形式, 而有的时候我们在传输文件的时候又希望直接传递一个文件就可以.\n或者将我们自己编写的python分发给其他人使用, 这个时候我们就需要对自己编写的python 包进行build打包\n具体操作如下\n1. 在项目目录下建立文件:\n```\npackaging_tutorial\n├── LICENSE\n├── README.md\n├── example_pkg\n│   └── __init__.py\n├── setup.py\n└── tests\n```\n* license 用来指明这个包遵循什么样的开源许可证\n* readme 告诉别人这个包的一些信息\n* example_pkg 则是这个包的实际代码\n* test 是这个包的test用例代码\n* setup.py 用来build 包的脚本\n\n在整个build过程中我们只需要编写setup.py 中的一些信息即可\n```python\nfrom setuptools import setup\n# setup\nsetup(\n    name='sample',   # 用于在pypi上面显示的名字\n    version='1.2.0',    # 项目的当前版本\n    description='A sample Python project',\n    long_description='',\n    long_description_content_type='text/x-rst', \n    url='https://github.com/xxxx/sampleproject',    # 项目的托管地址\n    author='A. Random Developer',\n    author_email='author@example.com',\n    license='MIT',\n    keywords='sample setuptools development', #用于此项目的搜索关键字\n    install_requires=['peppercorn'],    # 此项目的依赖\n    python_requires='>=3',          # 支持的python 版本\n    # 还有许多暂时用不到的选项...\n)\n\n```\n\n* 然后通过python 执行setup, 就会在当前工程下, dist目录创建一个tar格式的压缩包.\n```\npython setup.py sdist\n```\n* 如果需要打包成wheel\n```\npip install wheel\npython setup.py bdist_wheel\n```\n","slug":"python包打包分发","published":1,"updated":"2020-11-03T14:07:06.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjec0018o8t2gf4f27ud","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h1 id=\"python-包的打包与构建\"><a href=\"#python-包的打包与构建\" class=\"headerlink\" title=\"python 包的打包与构建\"></a>python 包的打包与构建</h1><p>由于python的源码都是开源的形式, 而有的时候我们在传输文件的时候又希望直接传递一个文件就可以.<br>或者将我们自己编写的python分发给其他人使用, 这个时候我们就需要对自己编写的python 包进行build打包<br>具体操作如下</p>\n<ol>\n<li>在项目目录下建立文件:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packaging_tutorial</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── example_pkg</span><br><span class=\"line\">│   └── __init__.py</span><br><span class=\"line\">├── setup.py</span><br><span class=\"line\">└── tests</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>license 用来指明这个包遵循什么样的开源许可证</li>\n<li>readme 告诉别人这个包的一些信息</li>\n<li>example_pkg 则是这个包的实际代码</li>\n<li>test 是这个包的test用例代码</li>\n<li>setup.py 用来build 包的脚本</li>\n</ul>\n<p>在整个build过程中我们只需要编写setup.py 中的一些信息即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> setuptools <span class=\"keyword\">import</span> setup</span><br><span class=\"line\"><span class=\"comment\"># setup</span></span><br><span class=\"line\">setup(</span><br><span class=\"line\">    name=<span class=\"string\">&#x27;sample&#x27;</span>,   <span class=\"comment\"># 用于在pypi上面显示的名字</span></span><br><span class=\"line\">    version=<span class=\"string\">&#x27;1.2.0&#x27;</span>,    <span class=\"comment\"># 项目的当前版本</span></span><br><span class=\"line\">    description=<span class=\"string\">&#x27;A sample Python project&#x27;</span>,</span><br><span class=\"line\">    long_description=<span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    long_description_content_type=<span class=\"string\">&#x27;text/x-rst&#x27;</span>, </span><br><span class=\"line\">    url=<span class=\"string\">&#x27;https://github.com/xxxx/sampleproject&#x27;</span>,    <span class=\"comment\"># 项目的托管地址</span></span><br><span class=\"line\">    author=<span class=\"string\">&#x27;A. Random Developer&#x27;</span>,</span><br><span class=\"line\">    author_email=<span class=\"string\">&#x27;author@example.com&#x27;</span>,</span><br><span class=\"line\">    license=<span class=\"string\">&#x27;MIT&#x27;</span>,</span><br><span class=\"line\">    keywords=<span class=\"string\">&#x27;sample setuptools development&#x27;</span>, <span class=\"comment\">#用于此项目的搜索关键字</span></span><br><span class=\"line\">    install_requires=[<span class=\"string\">&#x27;peppercorn&#x27;</span>],    <span class=\"comment\"># 此项目的依赖</span></span><br><span class=\"line\">    python_requires=<span class=\"string\">&#x27;&gt;=3&#x27;</span>,          <span class=\"comment\"># 支持的python 版本</span></span><br><span class=\"line\">    <span class=\"comment\"># 还有许多暂时用不到的选项...</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后通过python 执行setup, 就会在当前工程下, dist目录创建一个tar格式的压缩包.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup.py sdist</span><br></pre></td></tr></table></figure></li>\n<li>如果需要打包成wheel<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install wheel</span><br><span class=\"line\">python setup.py bdist_wheel</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h1 id=\"python-包的打包与构建\"><a href=\"#python-包的打包与构建\" class=\"headerlink\" title=\"python 包的打包与构建\"></a>python 包的打包与构建</h1><p>由于python的源码都是开源的形式, 而有的时候我们在传输文件的时候又希望直接传递一个文件就可以.<br>或者将我们自己编写的python分发给其他人使用, 这个时候我们就需要对自己编写的python 包进行build打包<br>具体操作如下</p>\n<ol>\n<li>在项目目录下建立文件:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packaging_tutorial</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── example_pkg</span><br><span class=\"line\">│   └── __init__.py</span><br><span class=\"line\">├── setup.py</span><br><span class=\"line\">└── tests</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>license 用来指明这个包遵循什么样的开源许可证</li>\n<li>readme 告诉别人这个包的一些信息</li>\n<li>example_pkg 则是这个包的实际代码</li>\n<li>test 是这个包的test用例代码</li>\n<li>setup.py 用来build 包的脚本</li>\n</ul>\n<p>在整个build过程中我们只需要编写setup.py 中的一些信息即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> setuptools <span class=\"keyword\">import</span> setup</span><br><span class=\"line\"><span class=\"comment\"># setup</span></span><br><span class=\"line\">setup(</span><br><span class=\"line\">    name=<span class=\"string\">&#x27;sample&#x27;</span>,   <span class=\"comment\"># 用于在pypi上面显示的名字</span></span><br><span class=\"line\">    version=<span class=\"string\">&#x27;1.2.0&#x27;</span>,    <span class=\"comment\"># 项目的当前版本</span></span><br><span class=\"line\">    description=<span class=\"string\">&#x27;A sample Python project&#x27;</span>,</span><br><span class=\"line\">    long_description=<span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">    long_description_content_type=<span class=\"string\">&#x27;text/x-rst&#x27;</span>, </span><br><span class=\"line\">    url=<span class=\"string\">&#x27;https://github.com/xxxx/sampleproject&#x27;</span>,    <span class=\"comment\"># 项目的托管地址</span></span><br><span class=\"line\">    author=<span class=\"string\">&#x27;A. Random Developer&#x27;</span>,</span><br><span class=\"line\">    author_email=<span class=\"string\">&#x27;author@example.com&#x27;</span>,</span><br><span class=\"line\">    license=<span class=\"string\">&#x27;MIT&#x27;</span>,</span><br><span class=\"line\">    keywords=<span class=\"string\">&#x27;sample setuptools development&#x27;</span>, <span class=\"comment\">#用于此项目的搜索关键字</span></span><br><span class=\"line\">    install_requires=[<span class=\"string\">&#x27;peppercorn&#x27;</span>],    <span class=\"comment\"># 此项目的依赖</span></span><br><span class=\"line\">    python_requires=<span class=\"string\">&#x27;&gt;=3&#x27;</span>,          <span class=\"comment\"># 支持的python 版本</span></span><br><span class=\"line\">    <span class=\"comment\"># 还有许多暂时用不到的选项...</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后通过python 执行setup, 就会在当前工程下, dist目录创建一个tar格式的压缩包.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup.py sdist</span><br></pre></td></tr></table></figure></li>\n<li>如果需要打包成wheel<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install wheel</span><br><span class=\"line\">python setup.py bdist_wheel</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"rest fm data validator","date":"2017-06-10T08:46:14.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Rest Framework 参数效验\n\n在Django 和 RestFramework结合中, 我们需要定义一个serializer用来处理序列化和反序列化数据\n而在对数据的验证, 需要在serializer 中定义每个验证函数内部应该只有两种结果,\n\n1. 成功正常 return value\n2. 失败使用 serializers.ValidationError(message) 抛出错误信息到上层, 并返回响应\n\n\n```python\nfrom rest_framework import serializser\n\nclass XXXSerializer(serializser.Serializer):\n    id = serializser.IntegerField()    \n    username = serializser.CharField(max_length=1024)\n\n    class Meta:\n        fields = ['id', 'username', 'password',...]\n\n    # 验证方式一\n    def validate_fieldname(self, value):\n        \"\"\"验证指定field 是否符合规定\"\"\"\n        pass\n\n    # 验证方式二\n    def validate(self, attrs):\n        # attrs 包含了前端传递的参数, 是一个类dict\n        pass\n\n# 第三种\ndef validator_username(value):\n    \"\"\"\n        定义的函数要在定义field时, 通过field 选项, validators指定, 以list形式传入\n    \"\"\"     \n```\n一般在验证数据之后, 就需要对数据进行处理. 而serializer 提供两个实现方法供我们实现. \n##### 如果不是模型类 serializer 需要自己在方法中调用模型类完成数据库操作\n* create(validated_data) validated_data 为验证成功后的数据\n* update(instance, validated_data) instance 为对应的实例对象, validated_data 同上\n\n两者区别在, create 由于数据创建, 此时并不需要数据对象, 数据传递给data接收\nupdate 使用时, 需要将数据对象传递, 并传入更新的字段值, 数据传递 instance=model_obj, data=update_data\n\nserializer().is_valid() 验证数据, 结果返回 True/False   \n如果 is_valid 传递 raise_exception=True 参数时, 异常将会抛出到调用方由调用方处理\n\nserializer().save()     保存数据\nserializer.data         获取序列化后的数据\n\n","source":"_posts/rest-fm-data-validator.md","raw":"---\ntitle: rest fm data validator\ndate: 2017-6-10 16:46:14\ntags: rest, validator\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### Rest Framework 参数效验\n\n在Django 和 RestFramework结合中, 我们需要定义一个serializer用来处理序列化和反序列化数据\n而在对数据的验证, 需要在serializer 中定义每个验证函数内部应该只有两种结果,\n\n1. 成功正常 return value\n2. 失败使用 serializers.ValidationError(message) 抛出错误信息到上层, 并返回响应\n\n\n```python\nfrom rest_framework import serializser\n\nclass XXXSerializer(serializser.Serializer):\n    id = serializser.IntegerField()    \n    username = serializser.CharField(max_length=1024)\n\n    class Meta:\n        fields = ['id', 'username', 'password',...]\n\n    # 验证方式一\n    def validate_fieldname(self, value):\n        \"\"\"验证指定field 是否符合规定\"\"\"\n        pass\n\n    # 验证方式二\n    def validate(self, attrs):\n        # attrs 包含了前端传递的参数, 是一个类dict\n        pass\n\n# 第三种\ndef validator_username(value):\n    \"\"\"\n        定义的函数要在定义field时, 通过field 选项, validators指定, 以list形式传入\n    \"\"\"     \n```\n一般在验证数据之后, 就需要对数据进行处理. 而serializer 提供两个实现方法供我们实现. \n##### 如果不是模型类 serializer 需要自己在方法中调用模型类完成数据库操作\n* create(validated_data) validated_data 为验证成功后的数据\n* update(instance, validated_data) instance 为对应的实例对象, validated_data 同上\n\n两者区别在, create 由于数据创建, 此时并不需要数据对象, 数据传递给data接收\nupdate 使用时, 需要将数据对象传递, 并传入更新的字段值, 数据传递 instance=model_obj, data=update_data\n\nserializer().is_valid() 验证数据, 结果返回 True/False   \n如果 is_valid 传递 raise_exception=True 参数时, 异常将会抛出到调用方由调用方处理\n\nserializer().save()     保存数据\nserializer.data         获取序列化后的数据\n\n","slug":"rest-fm-data-validator","published":1,"updated":"2020-11-03T14:07:06.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjec001ao8t2f1f2anll","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Rest-Framework-参数效验\"><a href=\"#Rest-Framework-参数效验\" class=\"headerlink\" title=\"Rest Framework 参数效验\"></a>Rest Framework 参数效验</h3><p>在Django 和 RestFramework结合中, 我们需要定义一个serializer用来处理序列化和反序列化数据<br>而在对数据的验证, 需要在serializer 中定义每个验证函数内部应该只有两种结果,</p>\n<ol>\n<li>成功正常 return value</li>\n<li>失败使用 serializers.ValidationError(message) 抛出错误信息到上层, 并返回响应</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> serializser</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXSerializer</span>(<span class=\"params\">serializser.Serializer</span>):</span></span><br><span class=\"line\">    id = serializser.IntegerField()    </span><br><span class=\"line\">    username = serializser.CharField(max_length=<span class=\"number\">1024</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        fields = [<span class=\"string\">&#x27;id&#x27;</span>, <span class=\"string\">&#x27;username&#x27;</span>, <span class=\"string\">&#x27;password&#x27;</span>,...]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 验证方式一</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validate_fieldname</span>(<span class=\"params\">self, value</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;验证指定field 是否符合规定&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 验证方式二</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validate</span>(<span class=\"params\">self, attrs</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># attrs 包含了前端传递的参数, 是一个类dict</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三种</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validator_username</span>(<span class=\"params\">value</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        定义的函数要在定义field时, 通过field 选项, validators指定, 以list形式传入</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span>     </span><br></pre></td></tr></table></figure>\n<p>一般在验证数据之后, 就需要对数据进行处理. 而serializer 提供两个实现方法供我们实现. </p>\n<h5 id=\"如果不是模型类-serializer-需要自己在方法中调用模型类完成数据库操作\"><a href=\"#如果不是模型类-serializer-需要自己在方法中调用模型类完成数据库操作\" class=\"headerlink\" title=\"如果不是模型类 serializer 需要自己在方法中调用模型类完成数据库操作\"></a>如果不是模型类 serializer 需要自己在方法中调用模型类完成数据库操作</h5><ul>\n<li>create(validated_data) validated_data 为验证成功后的数据</li>\n<li>update(instance, validated_data) instance 为对应的实例对象, validated_data 同上</li>\n</ul>\n<p>两者区别在, create 由于数据创建, 此时并不需要数据对象, 数据传递给data接收<br>update 使用时, 需要将数据对象传递, 并传入更新的字段值, 数据传递 instance=model_obj, data=update_data</p>\n<p>serializer().is_valid() 验证数据, 结果返回 True/False<br>如果 is_valid 传递 raise_exception=True 参数时, 异常将会抛出到调用方由调用方处理</p>\n<p>serializer().save()     保存数据<br>serializer.data         获取序列化后的数据</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"Rest-Framework-参数效验\"><a href=\"#Rest-Framework-参数效验\" class=\"headerlink\" title=\"Rest Framework 参数效验\"></a>Rest Framework 参数效验</h3><p>在Django 和 RestFramework结合中, 我们需要定义一个serializer用来处理序列化和反序列化数据<br>而在对数据的验证, 需要在serializer 中定义每个验证函数内部应该只有两种结果,</p>\n<ol>\n<li>成功正常 return value</li>\n<li>失败使用 serializers.ValidationError(message) 抛出错误信息到上层, 并返回响应</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> serializser</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXSerializer</span>(<span class=\"params\">serializser.Serializer</span>):</span></span><br><span class=\"line\">    id = serializser.IntegerField()    </span><br><span class=\"line\">    username = serializser.CharField(max_length=<span class=\"number\">1024</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        fields = [<span class=\"string\">&#x27;id&#x27;</span>, <span class=\"string\">&#x27;username&#x27;</span>, <span class=\"string\">&#x27;password&#x27;</span>,...]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 验证方式一</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validate_fieldname</span>(<span class=\"params\">self, value</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;验证指定field 是否符合规定&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 验证方式二</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validate</span>(<span class=\"params\">self, attrs</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># attrs 包含了前端传递的参数, 是一个类dict</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三种</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validator_username</span>(<span class=\"params\">value</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        定义的函数要在定义field时, 通过field 选项, validators指定, 以list形式传入</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span>     </span><br></pre></td></tr></table></figure>\n<p>一般在验证数据之后, 就需要对数据进行处理. 而serializer 提供两个实现方法供我们实现. </p>\n<h5 id=\"如果不是模型类-serializer-需要自己在方法中调用模型类完成数据库操作\"><a href=\"#如果不是模型类-serializer-需要自己在方法中调用模型类完成数据库操作\" class=\"headerlink\" title=\"如果不是模型类 serializer 需要自己在方法中调用模型类完成数据库操作\"></a>如果不是模型类 serializer 需要自己在方法中调用模型类完成数据库操作</h5><ul>\n<li>create(validated_data) validated_data 为验证成功后的数据</li>\n<li>update(instance, validated_data) instance 为对应的实例对象, validated_data 同上</li>\n</ul>\n<p>两者区别在, create 由于数据创建, 此时并不需要数据对象, 数据传递给data接收<br>update 使用时, 需要将数据对象传递, 并传入更新的字段值, 数据传递 instance=model_obj, data=update_data</p>\n<p>serializer().is_valid() 验证数据, 结果返回 True/False<br>如果 is_valid 传递 raise_exception=True 参数时, 异常将会抛出到调用方由调用方处理</p>\n<p>serializer().save()     保存数据<br>serializer.data         获取序列化后的数据</p>\n"},{"title":"分布式之负载均衡","date":"2018-10-20T10:17:10.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### 分布式之负载均衡\n  当业务访问量上来了之后, 公司的应用架构在第一次拆分之后. 就会形成一个垂直架构, 下一次架构设计将会转变成分布式或者微服务架构了.\n哪么在这之前, 所面临的第一个问题就是负载均衡问题. 因为, 分布式应用主要解决用户访问量的大的情况. 通过对一个单体应用进行水平扩展, \n将一个服务器集群, 在逻辑上抽象成一个单独的应用, 对外提供服务.\n  哪么, 首先要解决的一个问题就是, 当多台服务器形成集群了之后每一次用户的请求, 在分布式应用下该如何进行处理. 解决这一问题的技术方案就叫做负载均衡\n通过不同的负载算法, 将此次请求转发到指定的服务器上进行处理. 这个过程和我们在生产中使用nginx 负载多个web应用的原理是一样的. 不同的是一般我们在负载均衡\n层面一般还会处理用户鉴权\n\n\n### Python + Grpc 技术栈引入\n  grpc 由Google 开发, 是一个高性能、开源和通用的 RPC 框架. 数据传输使用 protobuf 格式, 类二进制的json. 在使用grpc之前需要使用protobuf定义消息类型,并使用proto生成对应的python代码.\n  \n","source":"_posts/分布式之负载均衡.md","raw":"---\ntitle: 分布式之负载均衡\ndate: 2018-10-20 18:17:10\ntags: 分布式\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### 分布式之负载均衡\n  当业务访问量上来了之后, 公司的应用架构在第一次拆分之后. 就会形成一个垂直架构, 下一次架构设计将会转变成分布式或者微服务架构了.\n哪么在这之前, 所面临的第一个问题就是负载均衡问题. 因为, 分布式应用主要解决用户访问量的大的情况. 通过对一个单体应用进行水平扩展, \n将一个服务器集群, 在逻辑上抽象成一个单独的应用, 对外提供服务.\n  哪么, 首先要解决的一个问题就是, 当多台服务器形成集群了之后每一次用户的请求, 在分布式应用下该如何进行处理. 解决这一问题的技术方案就叫做负载均衡\n通过不同的负载算法, 将此次请求转发到指定的服务器上进行处理. 这个过程和我们在生产中使用nginx 负载多个web应用的原理是一样的. 不同的是一般我们在负载均衡\n层面一般还会处理用户鉴权\n\n\n### Python + Grpc 技术栈引入\n  grpc 由Google 开发, 是一个高性能、开源和通用的 RPC 框架. 数据传输使用 protobuf 格式, 类二进制的json. 在使用grpc之前需要使用protobuf定义消息类型,并使用proto生成对应的python代码.\n  \n","slug":"分布式之负载均衡","published":1,"updated":"2020-11-03T14:07:06.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjef001co8t2cdf0e88z","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"分布式之负载均衡\"><a href=\"#分布式之负载均衡\" class=\"headerlink\" title=\"分布式之负载均衡\"></a>分布式之负载均衡</h3><p>  当业务访问量上来了之后, 公司的应用架构在第一次拆分之后. 就会形成一个垂直架构, 下一次架构设计将会转变成分布式或者微服务架构了.<br>哪么在这之前, 所面临的第一个问题就是负载均衡问题. 因为, 分布式应用主要解决用户访问量的大的情况. 通过对一个单体应用进行水平扩展,<br>将一个服务器集群, 在逻辑上抽象成一个单独的应用, 对外提供服务.<br>  哪么, 首先要解决的一个问题就是, 当多台服务器形成集群了之后每一次用户的请求, 在分布式应用下该如何进行处理. 解决这一问题的技术方案就叫做负载均衡<br>通过不同的负载算法, 将此次请求转发到指定的服务器上进行处理. 这个过程和我们在生产中使用nginx 负载多个web应用的原理是一样的. 不同的是一般我们在负载均衡<br>层面一般还会处理用户鉴权</p>\n<h3 id=\"Python-Grpc-技术栈引入\"><a href=\"#Python-Grpc-技术栈引入\" class=\"headerlink\" title=\"Python + Grpc 技术栈引入\"></a>Python + Grpc 技术栈引入</h3><p>  grpc 由Google 开发, 是一个高性能、开源和通用的 RPC 框架. 数据传输使用 protobuf 格式, 类二进制的json. 在使用grpc之前需要使用protobuf定义消息类型,并使用proto生成对应的python代码.</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"分布式之负载均衡\"><a href=\"#分布式之负载均衡\" class=\"headerlink\" title=\"分布式之负载均衡\"></a>分布式之负载均衡</h3><p>  当业务访问量上来了之后, 公司的应用架构在第一次拆分之后. 就会形成一个垂直架构, 下一次架构设计将会转变成分布式或者微服务架构了.<br>哪么在这之前, 所面临的第一个问题就是负载均衡问题. 因为, 分布式应用主要解决用户访问量的大的情况. 通过对一个单体应用进行水平扩展,<br>将一个服务器集群, 在逻辑上抽象成一个单独的应用, 对外提供服务.<br>  哪么, 首先要解决的一个问题就是, 当多台服务器形成集群了之后每一次用户的请求, 在分布式应用下该如何进行处理. 解决这一问题的技术方案就叫做负载均衡<br>通过不同的负载算法, 将此次请求转发到指定的服务器上进行处理. 这个过程和我们在生产中使用nginx 负载多个web应用的原理是一样的. 不同的是一般我们在负载均衡<br>层面一般还会处理用户鉴权</p>\n<h3 id=\"Python-Grpc-技术栈引入\"><a href=\"#Python-Grpc-技术栈引入\" class=\"headerlink\" title=\"Python + Grpc 技术栈引入\"></a>Python + Grpc 技术栈引入</h3><p>  grpc 由Google 开发, 是一个高性能、开源和通用的 RPC 框架. 数据传输使用 protobuf 格式, 类二进制的json. 在使用grpc之前需要使用protobuf定义消息类型,并使用proto生成对应的python代码.</p>\n"},{"title":"微服务理解","date":"2019-10-22T14:04:30.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n### 微服务\n微服务是一种设计思想, 目的是通过对微服务水平扩展, 解决传统单体应用在业务量上升时遇到的问题.\n并且微服务应该划分团体, 由专业方向上的人做专业的事情, 所以一个团队中, 可能存在ui, 前端, 开发, dba, 运维成员. 形成一个独立的团队\n负责功能单一的服务, 致力于职责单一, 低耦合, 高内聚. 将问题产生概率降到最小.\n\n1. 微服务将职责单一的功能放在独立的服务中\n2. 每个服务运行在独立的进程中\n3. 每个服务有多个实例运行, 每个实例可以运行在容器化平台内. 达到平滑伸缩效果\n4. 每个服务应该有自己的数据管理, 如, db, redis, mq\n5. 每个服务都应该有自己的运营平台, 服务应该高度自治\n6. 每个服务应该可以水平扩展\n\n","source":"_posts/微服务理解.md","raw":"---\ntitle: 微服务理解\ndate: 2019-10-22 22:04:30\ntags: 微服务\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n### 微服务\n微服务是一种设计思想, 目的是通过对微服务水平扩展, 解决传统单体应用在业务量上升时遇到的问题.\n并且微服务应该划分团体, 由专业方向上的人做专业的事情, 所以一个团队中, 可能存在ui, 前端, 开发, dba, 运维成员. 形成一个独立的团队\n负责功能单一的服务, 致力于职责单一, 低耦合, 高内聚. 将问题产生概率降到最小.\n\n1. 微服务将职责单一的功能放在独立的服务中\n2. 每个服务运行在独立的进程中\n3. 每个服务有多个实例运行, 每个实例可以运行在容器化平台内. 达到平滑伸缩效果\n4. 每个服务应该有自己的数据管理, 如, db, redis, mq\n5. 每个服务都应该有自己的运营平台, 服务应该高度自治\n6. 每个服务应该可以水平扩展\n\n","slug":"微服务理解","published":1,"updated":"2020-11-03T14:07:06.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjeo0021o8t22r5900w7","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h3><p>微服务是一种设计思想, 目的是通过对微服务水平扩展, 解决传统单体应用在业务量上升时遇到的问题.<br>并且微服务应该划分团体, 由专业方向上的人做专业的事情, 所以一个团队中, 可能存在ui, 前端, 开发, dba, 运维成员. 形成一个独立的团队<br>负责功能单一的服务, 致力于职责单一, 低耦合, 高内聚. 将问题产生概率降到最小.</p>\n<ol>\n<li>微服务将职责单一的功能放在独立的服务中</li>\n<li>每个服务运行在独立的进程中</li>\n<li>每个服务有多个实例运行, 每个实例可以运行在容器化平台内. 达到平滑伸缩效果</li>\n<li>每个服务应该有自己的数据管理, 如, db, redis, mq</li>\n<li>每个服务都应该有自己的运营平台, 服务应该高度自治</li>\n<li>每个服务应该可以水平扩展</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h3 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h3><p>微服务是一种设计思想, 目的是通过对微服务水平扩展, 解决传统单体应用在业务量上升时遇到的问题.<br>并且微服务应该划分团体, 由专业方向上的人做专业的事情, 所以一个团队中, 可能存在ui, 前端, 开发, dba, 运维成员. 形成一个独立的团队<br>负责功能单一的服务, 致力于职责单一, 低耦合, 高内聚. 将问题产生概率降到最小.</p>\n<ol>\n<li>微服务将职责单一的功能放在独立的服务中</li>\n<li>每个服务运行在独立的进程中</li>\n<li>每个服务有多个实例运行, 每个实例可以运行在容器化平台内. 达到平滑伸缩效果</li>\n<li>每个服务应该有自己的数据管理, 如, db, redis, mq</li>\n<li>每个服务都应该有自己的运营平台, 服务应该高度自治</li>\n<li>每个服务应该可以水平扩展</li>\n</ol>\n"},{"title":"支付掉单现象","date":"2017-10-28T02:33:02.000Z","_content":"#### ***本文章内容归作者所有, 如需转载请注明来源***\n## 电商支付过程中的掉单现象","source":"_posts/支付掉单现象.md","raw":"---\ntitle: 支付掉单现象\ndate: 2017-10-28 10:33:02\ntags: Web\n---\n#### ***本文章内容归作者所有, 如需转载请注明来源***\n## 电商支付过程中的掉单现象","slug":"支付掉单现象","published":1,"updated":"2020-11-03T14:07:06.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4qsjep0022o8t22yzcbol8","content":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"电商支付过程中的掉单现象\"><a href=\"#电商支付过程中的掉单现象\" class=\"headerlink\" title=\"电商支付过程中的掉单现象\"></a>电商支付过程中的掉单现象</h2>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"本文章内容归作者所有-如需转载请注明来源\"><a href=\"#本文章内容归作者所有-如需转载请注明来源\" class=\"headerlink\" title=\"本文章内容归作者所有, 如需转载请注明来源\"></a><strong><em>本文章内容归作者所有, 如需转载请注明来源</em></strong></h4><h2 id=\"电商支付过程中的掉单现象\"><a href=\"#电商支付过程中的掉单现象\" class=\"headerlink\" title=\"电商支付过程中的掉单现象\"></a>电商支付过程中的掉单现象</h2>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckh4qsjd70001o8t2fvlg774n","tag_id":"ckh4qsjdf0004o8t200do8lul","_id":"ckh4qsjdt000co8t20u6xcyu8"},{"post_id":"ckh4qsjdq000ao8t23zg18kl1","tag_id":"ckh4qsjdf0004o8t200do8lul","_id":"ckh4qsjdu000fo8t269ie4e7u"},{"post_id":"ckh4qsjda0003o8t2fm8ofp6w","tag_id":"ckh4qsjdf0004o8t200do8lul","_id":"ckh4qsjdx000jo8t2h50e9vaf"},{"post_id":"ckh4qsjdh0006o8t2di75ewp0","tag_id":"ckh4qsjdw000io8t230r6a3r5","_id":"ckh4qsje0000oo8t24a7zfhze"},{"post_id":"ckh4qsjdn0008o8t20vuk8vu9","tag_id":"ckh4qsjdz000mo8t2frrec1nj","_id":"ckh4qsje2000so8t2hg276vtk"},{"post_id":"ckh4qsjdu000eo8t2ephh7sy7","tag_id":"ckh4qsje1000qo8t29fg6c8vd","_id":"ckh4qsje5000wo8t26ps68vcu"},{"post_id":"ckh4qsjdw000ho8t28snm75gg","tag_id":"ckh4qsje3000uo8t2cgbuhjzh","_id":"ckh4qsje70010o8t2gpdd5e09"},{"post_id":"ckh4qsjdx000ko8t29srx6g12","tag_id":"ckh4qsje6000zo8t2d6j8dkfo","_id":"ckh4qsjea0015o8t219ezbkf5"},{"post_id":"ckh4qsjdy000lo8t20t7n6qlz","tag_id":"ckh4qsje90013o8t27kjxfmrs","_id":"ckh4qsjec0019o8t2e4srdh8u"},{"post_id":"ckh4qsjdz000no8t2hwiq0kl0","tag_id":"ckh4qsjeb0017o8t2fdn1ffpq","_id":"ckh4qsjeg001do8t2b6cx0d1v"},{"post_id":"ckh4qsje0000po8t2fm20gzki","tag_id":"ckh4qsjef001bo8t29nlb54bv","_id":"ckh4qsjeh001fo8t27ipf8nsg"},{"post_id":"ckh4qsje1000ro8t2gwepf865","tag_id":"ckh4qsjeg001eo8t28nr577cm","_id":"ckh4qsjeh001ho8t22he9hg05"},{"post_id":"ckh4qsje4000vo8t2gcdk4a9l","tag_id":"ckh4qsjeh001go8t2g5zk363y","_id":"ckh4qsjeh001jo8t25vq72lre"},{"post_id":"ckh4qsje5000xo8t2b6q51h3o","tag_id":"ckh4qsjeh001io8t20dt30enh","_id":"ckh4qsjei001lo8t2hknpd3d8"},{"post_id":"ckh4qsje6000yo8t2hi8e7zls","tag_id":"ckh4qsjei001ko8t2984f3tru","_id":"ckh4qsjei001no8t22lz6f9xh"},{"post_id":"ckh4qsje70011o8t2dbvy2dc5","tag_id":"ckh4qsjei001mo8t223bwa77v","_id":"ckh4qsjej001po8t27zh2hec9"},{"post_id":"ckh4qsje90012o8t2fz0fd9p9","tag_id":"ckh4qsjei001oo8t29skofvw3","_id":"ckh4qsjej001ro8t28to7hlzo"},{"post_id":"ckh4qsjea0014o8t24kl09rq9","tag_id":"ckh4qsjej001qo8t204lx1bes","_id":"ckh4qsjek001to8t2grhe06n2"},{"post_id":"ckh4qsjeb0016o8t2024k0ftd","tag_id":"ckh4qsjej001so8t2drrsgbjj","_id":"ckh4qsjek001vo8t2ey6o3uow"},{"post_id":"ckh4qsjec0018o8t2gf4f27ud","tag_id":"ckh4qsjek001uo8t2c6hub234","_id":"ckh4qsjel001xo8t24uy2bgvy"},{"post_id":"ckh4qsjec001ao8t2f1f2anll","tag_id":"ckh4qsjek001wo8t239omcl3o","_id":"ckh4qsjel001zo8t22i8dg76s"},{"post_id":"ckh4qsjef001co8t2cdf0e88z","tag_id":"ckh4qsjel001yo8t29uc4b2d9","_id":"ckh4qsjel0020o8t25pishnk1"},{"post_id":"ckh4qsjeo0021o8t22r5900w7","tag_id":"ckh4qsjep0023o8t22eb35qrf","_id":"ckh4qsjeq0025o8t2ctg04a0e"},{"post_id":"ckh4qsjep0022o8t22yzcbol8","tag_id":"ckh4qsjeq0024o8t2hyox4e8k","_id":"ckh4qsjer0026o8t2dp03hncv"}],"Tag":[{"name":"Flask","_id":"ckh4qsjdf0004o8t200do8lul"},{"name":"Flask, Sqlalchemy, db","_id":"ckh4qsjdw000io8t230r6a3r5"},{"name":"Flask, logging","_id":"ckh4qsjdz000mo8t2frrec1nj"},{"name":"Flask, Signal","_id":"ckh4qsje1000qo8t29fg6c8vd"},{"name":"Flask 钩子函数","_id":"ckh4qsje3000uo8t2cgbuhjzh"},{"name":"Mysql","_id":"ckh4qsje6000zo8t2d6j8dkfo"},{"name":"Django, 设计模式","_id":"ckh4qsje90013o8t27kjxfmrs"},{"name":"Eventlet, Flask, Sqlalchemy","_id":"ckh4qsjeb0017o8t2fdn1ffpq"},{"name":"Flask, Sqlalchemy","_id":"ckh4qsjef001bo8t29nlb54bv"},{"name":"Flask, route, Blueprint","_id":"ckh4qsjeg001eo8t28nr577cm"},{"name":"Flask, template","_id":"ckh4qsjeh001go8t2g5zk363y"},{"name":"TCP, Linux","_id":"ckh4qsjeh001io8t20dt30enh"},{"name":"python, gc, 内存管理","_id":"ckh4qsjei001ko8t2984f3tru"},{"name":"Mysql, 主从","_id":"ckh4qsjei001mo8t223bwa77v"},{"name":"python","_id":"ckh4qsjei001oo8t29skofvw3"},{"name":"Python, Memory","_id":"ckh4qsjej001qo8t204lx1bes"},{"name":"Redis","_id":"ckh4qsjej001so8t2drrsgbjj"},{"name":"build","_id":"ckh4qsjek001uo8t2c6hub234"},{"name":"rest, validator","_id":"ckh4qsjek001wo8t239omcl3o"},{"name":"分布式","_id":"ckh4qsjel001yo8t29uc4b2d9"},{"name":"微服务","_id":"ckh4qsjep0023o8t22eb35qrf"},{"name":"Web","_id":"ckh4qsjeq0024o8t2hyox4e8k"}]}}